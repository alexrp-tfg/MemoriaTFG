~
\chapter{Análisis de Tecnologías}
\label{sec:tecnologias}


Tal como se ha mencionado en el capítulo anterior, hay una tendencia general a usar TypeScript o Go para el desarrollo de el servidor de sincronización de multimedia y Flutter o PWA para el desarrollo de aplicaciones móviles debido a su popularidad y facilidad de uso.
Sin embargo, existen otras tecnologías que pueden ofrecer ventajas significativas en términos de rendimiento, seguridad y facilidad de desarrollo.

Se estudiarán los diferentes lenguajes y tecnologías como posibles candidatos para el desarrollo del servidor, entre ellos Rust, Go, C, C++, Python, Java y Ruby on Rails. Cada uno de estos lenguajes tiene sus propias ventajas y desventajas, y la elección del lenguaje adecuado dependerá de los requisitos específicos del proyecto, como la necesidad de alto rendimiento, seguridad en la gestión de memoria y facilidad de desarrollo.

También se estudiarán las tecnologías disponibles para el desarrollo de la aplicación móvil, entre ellas React Native, Flutter, PWA y Lynx.js. Cada una de estas tecnologías tiene sus propias ventajas y desventajas, y la elección de la tecnología adecuada dependerá de los requisitos específicos del proyecto, como la necesidad de una experiencia de usuario nativa, el rendimiento en dispositivos móviles y la facilidad de desarrollo.

\section{Almacenamiento de archivos}

Para el almacenamiento de los archivos multimedia tenemos dos opciones: un almacenamiento local o un almacenamiento en la nube.

\subsection{Almacenamiento local en servidor}
Esta opción implica alojar físicamente los archivos en los discos duros del servidor que ejecuta la aplicación.

\begin{itemize}
    \item \textbf{Ventajas:}
    \begin{itemize}
        \item \textbf{Control total}: Se tiene el control absoluto sobre los datos, la seguridad y la infraestructura.
        \item \textbf{Latencia baja}: La velocidad de acceso a los archivos es extremadamente alta, ya que no hay dependencias de la red externa.
        \item \textbf{Coste predecible}: Una vez adquirido el hardware de almacenamiento, los costes operativos son fijos. No hay gastos variables por el uso de ancho de banda o por la cantidad de datos almacenados.
    \end{itemize}

    \item \textbf{Desventajas:}
    \begin{itemize}
        \item \textbf{Escalabilidad limitada}: La capacidad de almacenamiento está restringida por el hardware físico. Escalar requiere la compra e instalación de más discos duros.
        \item \textbf{Coste inicial alto}: Requiere una inversión inicial significativa en hardware (servidores y almacenamiento).
        \item \textbf{Mantenimiento y seguridad}: Se es responsable de todo el mantenimiento, las copias de seguridad, la redundancia de datos (\texttt{RAID}) y la protección contra fallos.
        \item \textbf{Implementación de módulo de almacenamiento}: Hay que implementar el módulo que se va a encargar del almacenamiento de los archivos de forma local.
    \end{itemize}
\end{itemize}

\subsection{Almacenamiento en la nube}
Esta opción utiliza servicios de terceros como \textbf{Amazon S3}, \textbf{Google Cloud Storage} o \textbf{Microsoft Azure Blob Storage} para almacenar los archivos. Estos servicios se basan en la arquitectura de almacenamiento de objetos, optimizada para grandes volúmenes de datos no estructurados utilizando el protocolo de comunicación para transferencia de archivos S3.

\begin{itemize}
\item \textbf{Ventajas:}
    \begin{itemize}
        \item \textbf{Escalabilidad ilimitada}: Se puede almacenar prácticamente cualquier cantidad de datos sin preocuparse por la capacidad del hardware.
        \item \textbf{Coste flexible}: Se paga por el almacenamiento y el ancho de banda consumido, lo que lo hace ideal para proyectos con un crecimiento variable.
        \item \textbf{Fiabilidad y durabilidad}: Estos servicios ofrecen alta disponibilidad y durabilidad de los datos, con redundancia automática y copias de seguridad integradas.
        \item \textbf{Funcionalidades adicionales}: Suelen incluir características avanzadas como gestión de versiones, seguridad (acceso controlado) y replicación global.
        \item \textbf{Mismo protocolo de comunicación para varias opciones}: Hay varias opciones para cada protocolo de almacenamiento, lo que permitirá al usuario no tener que depender únicamente de un proveedor. Por ejemplo, el protocolo que utiliza Amazon (\gls{s3}) tiene varias opciones que son totalmente compatibles con ese mismo protocolo, como pueden ser \gls{minio}, \href{https://www.digitalocean.com/products/spaces}{DigitalOcean Spaces} o \href{https://wasabi.com/es}{Wasabi}, por lo que el usuario tan solo necesitaría cambiar los datos de conexión con los servicios en la configuración de la aplicación para cambiar de proveedor.
    \end{itemize}
\item \textbf{Desventajas:}
\begin{itemize}
\item \textbf{Coste recurrente}: Los gastos se acumulan con el uso, lo que puede ser un inconveniente a largo plazo para un proyecto con un gran volumen de usuarios.
\item \textbf{Dependencia de terceros}: Se depende de la disponibilidad y políticas del proveedor de servicios en la nube.
\item \textbf{Latencia variable}: El acceso a los archivos depende de la red, lo que puede introducir una latencia mayor que en el almacenamiento local.
\end{itemize}
\end{itemize}

Aunque hablamos de almacenamiento en la nube, existe la opción de utilizar una solución que imite el almacenamiento en la nube pero de forma local, como puede ser \gls{minio}, que es una solución de almacenamiento de objetos compatible con el protocolo S3 que se puede instalar en un servidor propio. De esta forma, se pueden aprovechar las ventajas del almacenamiento en la nube (escalabilidad, fiabilidad, funcionalidades adicionales) sin depender de un proveedor externo.

\section{Servidor}
El servidor de sincronización de multimedia es el componente central de la aplicación, encargado de gestionar la comunicación entre el cliente y el almacenamiento de fotos.
Disponemos de una amplia variedad a la hora de elegir un lenguaje/\gls{framework} para el desarrollo del servidor, cada uno con sus propias ventajas y desventajas.

Las principales soluciones serían:
\begin{itemize}
    \item \textbf{Node.js con TypeScript}: Muy popular, especialmente para aplicaciones web. Ofrece un ecosistema rico y una gran comunidad, siendo menos eficiente en términos de rendimiento y consumo de recursos con respecto a su competencia pero con una curva de aprendizaje más suave y una gran cantidad de bibliotecas disponibles.
    \item \textbf{Go}: Conocido por su eficiencia y facilidad de uso en aplicaciones concurrentes. Es una opción sólida para aplicaciones que requieren alto rendimiento y escalabilidad.
    \item \textbf{Rust}: Ofrece un alto rendimiento y seguridad en la gestión de memoria. Aunque tiene una curva de aprendizaje más pronunciada, es ideal para aplicaciones que requieren alta concurrencia y eficiencia.
    \item \textbf{C}: Lenguaje de bajo nivel con alto rendimiento, pero su complejidad y la gestión manual de memoria lo hacen menos adecuado para aplicaciones web modernas.
    \item \textbf{C++}: Similar a C, pero con características de programación orientada a objetos. Ofrece un alto rendimiento, pero su complejidad y la gestión manual de memoria lo hacen menos adecuado para aplicaciones web modernas.
    \item \textbf{Python}: Muy utilizado en el ámbito de la ciencia de datos y aprendizaje automático, pero menos eficiente en términos de rendimiento y escalabilidad para aplicaciones web, además de contar con un \gls{tipado-dinamico} que puede llevar a errores en tiempo de ejecución.
    \item \textbf{Java}: Aunque es robusto y escalable, su complejidad y consumo de recursos lo hacen menos atractivo para aplicaciones ligeras.
    \item \textbf{Ruby on Rails}: Muy popular para aplicaciones web, pero menos eficiente en términos de rendimiento y escalabilidad. No se ha trabajado mucho con esta tecnología, por lo que no se tiene una experiencia directa con ella.
\end{itemize}

A continuación se muestra una comparativa de rendimiento de los lenguajes anteriormente mencionados, en la cual se han medido el tiempo de CPU y el uso de memoria en tres algoritmos diferentes: Bubble Sort, Monte Carlo Pi y Monte Carlo Pi con un generador de números aleatorios simple (\texttt{SimpleRNG}).

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{assets/rust-cpu-comparison.png}
  \caption{Comparativa de uso de CPU entre C, C++, Go, Java, Python y Rust (menos es mejor) \parencite{rust-for-safety-and-performance}}
  \label{fig:rust-cpu-comparison}
\end{figure}


\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{assets/rust-memory-comparison.png}
  \caption{Comparativa de uso de memoria entre C, C++, Go, Java, Python y Rust (menos es mejor) \parencite{rust-for-safety-and-performance}}
  \label{fig:rust-memory-comparison}
\end{figure}

Como se puede ver en las Figuras \ref{fig:rust-cpu-comparison} y \ref{fig:rust-memory-comparison}, Rust tiene un rendimiento muy bueno en comparación con otros lenguajes de programación, tanto en uso de CPU como en uso de memoria.

A partir de las Figuras, podemos definir dos fórmulas para calcular el porcentaje de mejora con respecto a los otros lenguajes de programación:
\begin{equation}
    \text{Mejora}_{\text{CPU}} (\%) = \left( \frac{T_{\text{\textit{lenguaje}}} - T_{\text{Rust}}}{T_{\text{\textit{lenguaje}}}} \right) \times 100
\end{equation}

\begin{equation}
    \text{Mejora}_{\text{Memoria}} (\%) = \left( \frac{M_{\text{\textit{lenguaje}}} - M_{\text{Rust}}}{M_{\text{\textit{lenguaje}}}} \right) \times 100
\end{equation}


Cogiendo Rust como referencia, puesto que es el que mejor resultados tiene en ambas métricas, obtenemos las siguientes tablas de comparación:

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Lenguaje} & \textbf{Bubble Sort} & \textbf{Monte Carlo Pi} & \textbf{Monte Carlo Pi (SimpleRNG)} \\
\hline
C      & 38.2\%  & 37.9\%  & -0.8\% \\
C++    & 38.2\%  & 55.5\%  & -0.8\% \\
Go     & 6.5\%   & 64.1\%  & 0.4\%           \\
Java   & 17.0\%  & 59.6\%  & 19.4\%          \\
Python & 98.0\%  & 99.3\%  & 99.4\%          \\
\hline
\end{tabular}
\caption{Porcentaje de mejora de Rust con respecto a otros lenguajes de programación en términos de tiempo de CPU. (Mayor es mejor)}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Lenguaje} & \textbf{Bubble Sort} & \textbf{Monte Carlo Pi} & \textbf{Monte Carlo Pi (SimpleRNG)} \\
\hline
C      & 89.8\%  & 20.4\%  & 25.6\%  \\
C++    & 45.1\%  & 45.3\%  & 45.9\%  \\
Go     & 65.4\%  & 43.5\%  & 44.0\%  \\
Java   & 97.8\%  & 95.4\%  & 95.4\%  \\
Python & 89.7\%  & 78.4\%  & 78.2\%  \\
\hline
\end{tabular}
\caption{Porcentaje de mejora de Rust con respecto a otros lenguajes de programación en términos de uso de memoria. (Mayor es mejor)}
\end{table}

Dado que para nuestro proyecto se busca la solución más eficiente (tanto en términos de velocidad como recursos) y segura, una vez vista la comparación entre las tecnologías candidatas, el análisis se puede reducir a una comparación entre Go y Rust, lenguajes que ofrecen un alto rendimiento y seguridad en la gestión de memoria.
Lenguajes como C, C++ han sido descartados puesto que, aunque ofrecen un alto rendimiento, su gestión de memoria es propensa a errores y fugas de memoria, lo que puede ser problemático en un desarrollo de código abierto y colaborativo.

Rust y Go son dos lenguajes de programación modernos que han ganado una popularidad considerable en los últimos años, especialmente en el desarrollo de sistemas y aplicaciones de alto rendimiento. Aunque ambos comparten objetivos como la eficiencia y la concurrencia, sus filosofías de diseño y enfoques para resolver problemas difieren significativamente.

\textbf{Rust} es un lenguaje de programación de sistemas enfocado en la seguridad de memoria y la concurrencia. Su principal objetivo es ofrecer el rendimiento de C/C++ sin los problemas comunes de gestión de memoria, como los punteros nulos o las \glspl{condicion-carrera}, gracias a su sistema de propiedad (\gls{rust-ownership}) y préstamos (\gls{rust-borrowing}).

\textbf{Go} (también conocido como Golang) es un lenguaje desarrollado por Google, diseñado para ser simple, eficiente y productivo, especialmente para la programación concurrente y de redes. Prioriza la simplicidad en su sintaxis y herramientas, facilitando una curva de aprendizaje suave.

\subsection{Gestión de memoria}
\subsubsection{Rust}

Rust implementa un sistema de gestión de memoria único basado en los conceptos de \textit{ownership}, \textit{borrowing} y \textit{\glspl{rust-lifetimes}}. Este sistema garantiza la seguridad de memoria en tiempo de compilación sin necesidad de un \acrfull{gc}.

El sistema de gestión de memoria de Rust se basa en las siguientes reglas (\cite{rustbook2024} Capítulo 4):
\begin{itemize}
    \item Cada valor en Rust tiene un único propietario (owner).
    \item Cuando el propietario sale del ámbito, el valor se libera automáticamente.
    \item Los valores pueden ser prestados (borrowed) de forma mutable o inmutable, pero no ambos al mismo tiempo.
    \item Solamente puede haber un préstamo mutable o múltiples préstamos inmutables a un valor al mismo tiempo. Un préstamo mutable no puede existir a la vez que un préstamo inmutable, dado que podría llevar a condiciones de carrera.
    \item Los préstamos tienen una duración (lifetime) que garantiza que los datos referenciados sigan siendo válidos durante su uso. El tiempo de vida de los préstamos se determina en tiempo de compilación, lo que evita errores comunes de punteros nulos o dangling pointers.
\end{itemize}

Gracias a ello, tenemos control preciso sobre la memoria, ausencia de pausas por GC, prevención de fugas de memoria y carreras de datos de forma estática. El compilador será muy estricto, lo que hará que prevengamos errores en tiempo de ejecución.

Todo este paradigma de programación es totalmente distinto a lo que estamos acostumbrados en otros lenguajes de programación como puede ser Java o c++/c, lo que puede llevar a una curva de aprendizaje más pronunciada, pero a largo plazo nos va a permitir desarrollar aplicaciones más seguras y eficientes.

\subsubsection{Go}

Go utiliza un recolector de basura para la gestión automática de la memoria. Este GC está optimizado para baja latencia, aunque introduce ciertas pausas (\cite{go-documentation}, The Go Memory Model).

Go está diseñado para ser un lenguaje de programación lo más eficiente posible para concurrencia, por lo que su modelo de memoria también está optimizado para facilitar la programación concurrente. Utiliza un modelo de memoria basado en \glspl{csp} (Communicating Sequential Processes \cite{communicating-sequential-processes}), donde las goroutines (hilos ligeros) se comunican a través de canales, evitando la necesidad de compartir memoria directamente.
\begin{itemize}
    \item \textbf{Ventajas:} Simplifica la gestión de memoria para el desarrollador, haciendo más sencillo el desarrollo de aplicaciones concurrentes. El lenguaje es más fácil de aprender y usar, especialmente para principiantes.
    \item \textbf{Desventajas:} Introduce una sobrecarga (overhead) y posibles pausas no determinísticas debido al GC, lo que puede ser un inconveniente en aplicaciones de tiempo real estricto.
\end{itemize}

\subsection{Rendimiento}
\subsubsection{Rust}
Rust está diseñado para ofrecer un rendimiento comparable al de C y C++. Sus abstracciones de ``coste cero'' aseguran que las características de alto nivel no impongan una penalización en tiempo de ejecución. La ausencia de GC también contribuye a un rendimiento predecible.

Rust ofrece varias abstracciones de coste cero como \texttt{iterators}, \texttt{closures} y \texttt{async/await} que permiten escribir código limpio y expresivo sin sacrificar el rendimiento. Además, su sistema de tipos y el modelo de propiedad permiten al compilador realizar optimizaciones agresivas que en otro lenguaje son imposibles.

En el rendimiento podemos distinguir entre dos aspectos:
\begin{itemize}
    \item \textbf{Compilación:} Los tiempos de compilación pueden ser más largos debido a las exhaustivas verificaciones que realiza el compilador.
    \item \textbf{Ejecución:} Muy alta velocidad de ejecución y uso eficiente de los recursos gracias a su modelo de propiedad.
\end{itemize}

\subsubsection{Go}

Go ofrece un buen rendimiento, aunque generalmente no alcanza el nivel de Rust o C++ en tareas que requieren máxima optimización a bajo nivel. Su compilador es notablemente rápido en comparación con el de Rust, dado que está enfocado a solucionar errores en ejecución y no en compilación.

Go utiliza un modelo de concurrencia basado en \glspl{goroutine} y canales (\cite{go-documentation}, The Go Memory Model), lo que permite un alto grado de paralelismo sin complicaciones adicionales. Esto lo hace ideal para aplicaciones que requieren manejar múltiples tareas simultáneamente, como servidores web o servicios de red.

\begin{itemize}
    \item \textbf{Compilación:} Tiempos de compilación muy rápidos, lo que agiliza el ciclo de desarrollo.
    \item \textbf{Ejecución:} Buen rendimiento para la mayoría de las aplicaciones, especialmente en \acrshort{i-o} y concurrencia. El GC puede impactar el rendimiento en ciertos escenarios.
\end{itemize}

\subsection{Concurrencia}
\subsubsection{Rust}

Rust aborda la concurrencia con un enfoque en la seguridad (``\gls{fearless-concurrency}'', \cite{rustbook2024}, Capítulo 16), el cual permite realizar operaciones concurrentes sin preocuparse por problemas usuales de la concurrencia como pueden ser las condiciones de carrera.
Su sistema de tipos y el modelo de propiedad previenen las carreras de datos en tiempo de compilación.
Utiliza primitivas como \texttt{async/await} para la programación asíncrona, además de hilos de sistema operativo, consiguiendo paralelismo para la programación asíncrona.

Rust permite la creación de hilos seguros y eficientes, y su modelo de propiedad garantiza que no haya condiciones de carrera. El compilador verifica en tiempo de compilación que no se acceda a datos compartidos de forma insegura gracias a su modelo de propiedad de variables, lo que reduce significativamente los errores comunes en la programación concurrente.
\begin{itemize}
    \item \textbf{Ventajas:} Concurrencia segura sin condiciones de carrera garantizada por el compilador. Buen soporte para paralelismo.
    \item \textbf{Desventajas:} La programación concurrente puede ser más verbosa o compleja de configurar inicialmente en comparación con Go.
\end{itemize}

\subsubsection{Go}

La concurrencia es una de las características estrella de Go. Se basa en \textit{goroutines} y \textit{canales} (channels) para la comunicación entre goroutines, siguiendo el paradigma de \acrfull{csp} \parencite{communicating-sequential-processes}.
Éste se basa en la idea de que las goroutines se comunican entre sí a través de canales sin acceder a las mismas posiciones de memoria (cada goroutine tiene su propia copia de el mensaje) y reduce el riesgo de condiciones de carrera.
Si se quiere tener una comunicación bidireccional, se tendría que utilizar un enfoque más tradicional mediante \glspl{mutex} o \glspl{semaforo} junto con \glspl{lock}, lo cual puede ser más complejo y propenso a errores.
\begin{itemize}
    \item \textbf{Ventajas:} Modelo de concurrencia muy simple y potente. Facilidad para escribir software concurrente y paralelo.
    \item \textbf{Desventajas:} Aunque las goroutines son ligeras, una mala gestión puede llevar a problemas de rendimiento o fugas de goroutines. Las condiciones de carrera son posibles y deben ser manejadas por el desarrollador.
\end{itemize}

\subsection{Sintaxis y curva de aprendizaje}
\subsubsection{Rust}
La sintaxis de Rust es moderna y expresiva, pero su sistema de tipos y el modelo de gestión de memoria (ownership y borrowing) introducen una curva de aprendizaje considerablemente más pronunciada que la de Go.
Ya se ha trabajado anteriormente con Rust, lo cual facilita el aprendizaje de este lenguaje.
Además, la documentación oficial de Rust es muy completa y está bien estructurada, contando con el libro oficial de rust \parencite{rustbook2024}, que ayuda a los nuevos usuarios a familiarizarse con el lenguaje.
\begin{itemize}
    \item \textbf{Ventajas:} Sintaxis potente que permite un control muy granular.
    \item \textbf{Desventajas:} Dificultad inicial alta para dominar los conceptos clave.
\end{itemize}

\subsubsection{Go}

Go fue diseñado con la simplicidad como uno de sus principios fundamentales. Su sintaxis es minimalista y fácil de aprender, especialmente para programadores con experiencia en lenguajes tipo C.
\begin{itemize}
    \item \textbf{Ventajas:} Curva de aprendizaje suave, alta legibilidad y productividad rápida.
    \item \textbf{Desventajas:} La simplicidad puede llevar a cierta verbosidad en algunos casos (por ejemplo, el manejo de errores antes de la versión 1.13 con \texttt{wrap error}).
\end{itemize}

\subsection{Sistema de tipos y abstracciones}
\subsubsection{Rust}

Rust posee un sistema de tipos estático, fuerte y muy rico, inspirado en lenguajes como \gls{haskell}. Incluye \textit{\gls{rust-traits}}, genéricos avanzados, \acrlong{adt} \gls{adt-gls} como \texttt{enum} y \texttt{struct} que, gracias a el \gls{pattern-matching} y el coste cero, nos permite un desarrollo muy expresivo y seguro.
\begin{itemize}
    \item \textbf{Ventajas:} Gran expresividad, seguridad de tipos, permite abstracciones potentes y seguras.
    \item \textbf{Desventajas:} Puede resultar complejo para quienes vienen de lenguajes con sistemas de tipos más simples.
\end{itemize}

\subsubsection{Go}

Go tiene un sistema de tipos estático y simple. Utiliza interfaces para la polimorfismo de forma implícita (tipado estructural). Los genéricos fueron añadidos en la versión 1.18, lo que ha expandido sus capacidades de abstracción.
\begin{itemize}
    \item \textbf{Ventajas:} Simplicidad en el sistema de tipos, interfaces fáciles de usar. La adición de genéricos ha mejorado la reutilización de código.
    \item \textbf{Desventajas:} Menos expresivo que el sistema de tipos de Rust. Antes de los genéricos, la falta de ellos era una limitación importante.
\end{itemize}

\subsection{Ecosistema y herramientas}
\subsubsection{Rust}

Rust cuenta con \textbf{Cargo}, una herramienta de gestión de dependencias y construcción de proyectos muy elogiada. El repositorio oficial de paquetes es \textbf{crates.io}, que alberga una cantidad creciente de bibliotecas.

Cargo además ofrece herramientas integradas para pruebas, documentación y gestión de versiones.
\begin{itemize}
    \item \textbf{Ventajas:} Herramientas robustas y unificadas. Comunidad activa y creciente.
    \item \textbf{Desventajas:} Aunque el ecosistema está creciendo rápidamente, puede no ser tan maduro como el de Go en ciertas áreas específicas (ej. algunas bibliotecas para servicios web muy específicos).
\end{itemize}

\subsubsection{Go}

Go posee una excelente librería estándar que cubre muchas necesidades comunes, especialmente en networking y servicios web. Sus herramientas de desarrollo (formateo, testing, profiling) están integradas en la distribución del lenguaje. Utiliza módulos de Go para la gestión de dependencias.
\begin{itemize}
    \item \textbf{Ventajas:} Librería estándar muy completa. Herramientas simples y efectivas. Compilación cruzada sencilla.
    \item \textbf{Desventajas:} Menor cantidad de bibliotecas de terceros para ciertos dominios muy especializados en comparación con lenguajes más antiguos, aunque el ecosistema es maduro para sus casos de uso principales.
\end{itemize}

\subsection{Manejo de errores}
\subsubsection{Rust}
Rust no utiliza excepciones. El manejo de errores se realiza principalmente a través de los tipos \texttt{Result<T, E>} y \texttt{Option<T>} y el pattern matching exhaustivo, que obligan al programador a considerar los casos de éxito y error explícitamente, sin posibilidad de compilar si no se manejan los errores correctamente.
\begin{itemize}
    \item \textbf{Ventajas:} Manejo de errores robusto y explícito, que previene errores no gestionados.
    \item \textbf{Desventajas:} Puede resultar verboso en comparación con las excepciones, aunque el operador \texttt{?}\footnote{El operador ? devuelve el error si ocurre sin necesidad de introducir un \textit{match}} ayuda a mitigar esto.
\end{itemize}

\subsubsection{Go}
Go maneja los errores retornándolos como el último valor de una función. Por convención, un error es un valor que satisface la interfaz \texttt{error}. Esto requiere comprobaciones explícitas \texttt{if err != nil}.
El manejo de errores en este caso no es exhaustivo.
\begin{itemize}
    \item \textbf{Ventajas:} Simple y explícito.
    \item \textbf{Desventajas:} Puede llevar a código repetitivo y verboso con múltiples comprobaciones de error.
\end{itemize}

\subsection{Casos de uso principales}
\subsubsection{Rust}

\begin{itemize}
    \item Programación de sistemas (sistemas operativos, navegadores web).
    \item Motores de videojuegos.
    \item \acrfull{cli}.
    \item Desarrollo en \gls{webassembly} (WASM).
    \item Sistemas embebidos.
    \item Aplicaciones que requieren alto rendimiento y seguridad de memoria.
\end{itemize}

\subsubsection{Go}

\begin{itemize}
    \item Servicios de backend y microservicios.
    \item Herramientas de red y servidores.
    \item Herramientas de \gls{devops} y CLI.
    \item Bases de datos distribuidas.
    \item Aplicaciones concurrentes.
\end{itemize}

\subsection{Resumen de ventajas y desventajas}

\subsubsection{Rust}
Ventajas:
\begin{itemize}
    \item Seguridad de memoria sin recolector de basura.
    \item Alto rendimiento, comparable a C/C++.
    \item Concurrencia segura ("fearless concurrency").
    \item Sistema de tipos rico y expresivo.
    \item Excelente gestor de paquetes y herramientas (Cargo).
    \item Creciente popularidad en dominios críticos.
\end{itemize}
Desventajas:
\begin{itemize}
    \item Curva de aprendizaje pronunciada.
    \item Tiempos de compilación más lentos.
    \item Mayor verbosidad en algunos aspectos debido a la gestión de memoria y errores.
\end{itemize}

\subsubsection{Go}
Ventajas:

\begin{itemize}
    \item Simplicidad y facilidad de aprendizaje.
    \item Modelo de concurrencia simple y potente (goroutines, channels).
    \item Tiempos de compilación muy rápidos.
    \item Librería estándar robusta.
    \item Buena productividad para el desarrollo de servicios de red.
    \item Respaldo de Google y una comunidad madura.
\end{itemize}
Desventajas:
\begin{itemize}
    \item Rendimiento generalmente inferior a Rust en cómputo intensivo.
    \item El recolector de basura puede introducir latencias.
    \item El sistema de tipos es menos expresivo que el de Rust (aunque mejorado con genéricos).
    \item El manejo de errores puede ser verboso.
\end{itemize}


\section{Aplicación móvil}

Para el desarrollo de aplicaciones móviles en el contexto de bibliotecas de archivos multimedia, existen varias tecnologías que ofrecen diferentes enfoques y características. A continuación se presenta un análisis detallado de las principales opciones disponibles: React Native \parencite{danielsson2016reactnative}, Flutter, Progressive Web Apps (PWA) \parencite{tandel2018impact} y Lynx.js \parencite{danielsson2016reactnative} \parencite{lynx-documentation}.

\subsection{Arquitectura y funcionamiento}

\paragraph{React Native}
(\cite{react-native-documentation}, \href{https://reactnative.dev/architecture/overview}{Arquitectura}) Desarrollado por Meta, permite crear aplicaciones nativas usando JavaScript y React. Su arquitectura se basa en un \gls{bridge} que comunica el código JavaScript con los componentes nativos de la plataforma, renderizando una interfaz de usuario verdaderamente nativa. Permite la integración de código nativo si es necesario y ofrece \textit{hot reload} para agilizar el desarrollo.

\paragraph{Flutter}
(\cite{flutter-documentation}, \href{https://docs.flutter.dev/resources/architectural-overview}{Arquitectura}) Creado por Google, utiliza el lenguaje Dart y renderiza la interfaz de usuario desde cero mediante su propio motor gráfico, \gls{skia}. Esto garantiza una apariencia y comportamiento consistentes en todas las plataformas. Su arquitectura se compone de un \textit{engine} en C++ y un \textit{framework} en Dart que gestiona los widgets. La compilación es \gls{ahead-of-time} (AOT) para producción, lo que optimiza el rendimiento.

\paragraph{PWA}
(\cite{pwa-documentation}) Las \acrfull{pwa} son aplicaciones web que utilizan tecnologías estándar para ofrecer una experiencia similar a la nativa. Su arquitectura se apoya en \glspl{service-worker} para la funcionalidad offline y el cacheo de recursos, un \textit{Web App Manifest} para la instalación en el dispositivo, y un diseño \textit{responsive} para adaptarse a diferentes tamaños de pantalla.

\paragraph{Lynx.js}
(\cite{lynx-documentation}, \href{https://lynxjs.org/react/lifecycle.html#dual-thread-architecture-design}{Arquitectura doble hilo}) Es una tecnología emergente que ejecuta JavaScript en un \textit{runtime} nativo sin necesidad de un WebView, similar a React Native pero con un enfoque en el rendimiento a través de una arquitectura de doble hilo. Promete una compilación \textit{just-in-time} (JIT) optimizada para móviles y un \textit{bridge} de comunicación más eficiente.

\subsection{Rendimiento}

\paragraph{React Native}
Ofrece un buen rendimiento al utilizar componentes nativos, pero la comunicación a través del \textit{bridge} puede introducir latencia, especialmente en interacciones complejas o animaciones intensivas. Para tareas de alto rendimiento como el procesamiento de imágenes, a menudo se requiere el uso de bibliotecas de terceros que implementan la lógica en código nativo.

\paragraph{Flutter}
Proporciona un rendimiento alto y consistente, con animaciones fluidas a 60 \acrshort{fps} en la mayoría de los dispositivos. Al no depender de un \textit{bridge} y compilar a código nativo, la comunicación con las APIs del sistema es directa. Su motor Skia es especialmente eficiente para tareas gráficas intensivas.

\paragraph{PWA}
El rendimiento es generalmente inferior al de las soluciones nativas, ya que está limitado por el motor del navegador. Aunque las tecnologías como \gls{webassembly} y \gls{webgl} han mejorado las capacidades, las tareas intensivas pueden sufrir en dispositivos de gama baja o media.

\paragraph{Lynx.js}
Promete un rendimiento superior al de React Native gracias a su arquitectura de doble hilo, que separa la lógica de la aplicación de la renderización de la interfaz. Sin embargo, al ser una tecnología nueva, hay pocos datos empíricos que respalden estas afirmaciones en aplicaciones complejas del mundo real.

\subsection{Ecosistema y comunidad}

\paragraph{React Native}
Cuenta con el ecosistema más maduro y una de las comunidades más grandes en el desarrollo móvil multiplataforma. Existe una vasta cantidad de bibliotecas, herramientas y tutoriales disponibles, lo que facilita la resolución de problemas y la integración de funcionalidades.

\paragraph{Flutter}
Su ecosistema ha crecido rápidamente y es muy activo, con un fuerte respaldo de Google. Aunque tiene menos paquetes que React Native, la calidad y el mantenimiento de las bibliotecas principales son excelentes. La comunidad es conocida por ser colaborativa y acogedora.

\paragraph{PWA}
Se beneficia del ecosistema web en su totalidad, que es el más grande y diverso de todos. Sin embargo, encontrar paquetes específicos para funcionalidades móviles avanzadas puede ser más complicado, y la compatibilidad entre navegadores sigue siendo un desafío.

\paragraph{Lynx.js}
Su ecosistema es muy nuevo y la comunidad es muy pequeña. La documentación es escasa y encontrar soluciones a problemas específicos puede ser difícil. Su desarrollo está impulsado principalmente por TikTok, lo que plantea dudas sobre su viabilidad a largo plazo como proyecto de código abierto.

\subsection{Curva de aprendizaje y desarrollo}

\paragraph{React Native}
La curva de aprendizaje es relativamente suave para los desarrolladores con experiencia en React y JavaScript. La reutilización de código entre iOS y Android es alta (70-80\%), lo que acelera el desarrollo. El \textit{hot reload} es una característica muy apreciada.

\paragraph{Flutter}
Requiere aprender el lenguaje Dart y el paradigma de \textit{widgets} de Flutter, lo que puede suponer una curva de aprendizaje inicial más pronunciada. Sin embargo, una vez superada, el desarrollo es muy productivo gracias a herramientas como el \textit{hot reload} y una documentación excelente.

\paragraph{PWA}
El desarrollo es accesible para cualquier desarrollador web. Se utiliza una única base de código para la web y el móvil, y la distribución es tan simple como desplegar un sitio web, sin necesidad de pasar por las tiendas de aplicaciones.

\paragraph{Lynx.js}
Utiliza JavaScript/TypeScript, lo que lo hace familiar para los desarrolladores web. Sin embargo, la falta de documentación y ejemplos hace que la curva de aprendizaje sea artificialmente alta debido a la necesidad de experimentar y descubrir cómo funcionan las cosas.

\subsection{Análisis específico para bibliotecas de fotos}

\subsubsection{Procesamiento de Imágenes}
Para una aplicación de gestión de fotos, el procesamiento eficiente de imágenes es crucial.
\begin{itemize}
    \item \textbf{Flutter}: Sobresale gracias a su motor gráfico Skia, ideal para la manipulación de imágenes y la creación de interfaces personalizadas.
    \item \textbf{React Native}: Depende de bibliotecas nativas para el procesamiento intensivo, lo que puede añadir complejidad.
    \item \textbf{PWA}: Está limitado por la API Canvas y WebGL del navegador, cuyo rendimiento puede ser variable.
    \item \textbf{Lynx.js}: Promete buen rendimiento, pero carece de pruebas concluyentes.
\end{itemize}

\subsubsection{Gestión de Memoria}
La gestión de grandes colecciones de fotos requiere un manejo de memoria eficiente.
\begin{itemize}
    \item \textbf{Flutter}: Ofrece un control granular sobre la memoria y un \textit{garbage collector} optimizado para Dart.
    \item \textbf{React Native}: Depende del \textit{garbage collector} de JavaScript, lo que puede llevar a fugas de memoria si no se gestiona con cuidado.
    \item \textbf{PWA}: La gestión de memoria es automática y depende del navegador, con limitaciones en dispositivos más antiguos.
    \item \textbf{Lynx.js}: Promete optimizaciones, pero no están verificadas en la práctica.
\end{itemize}

\subsubsection{Carga y Visualización}
La carga perezosa (\textit{lazy loading}) y el cacheo son fundamentales para una experiencia de usuario fluida.
\begin{itemize}
    \item \textbf{Flutter}: Proporciona excelentes herramientas nativas para \textit{lazy loading} y cacheo eficiente.
    \item \textbf{React Native}: Existen bibliotecas muy populares y eficientes como \texttt{react-native-fast-image}.
    \item \textbf{PWA}: Los \textit{Service Workers} permiten un cacheo robusto, pero el almacenamiento local tiene limitaciones.
    \item \textbf{Lynx.js}: Ofrece un componente optimizado para la carga de imágenes y datos.
\end{itemize}

\subsection{Conclusiones}

Dado que el proyecto busca crear una biblioteca de fotos de código abierto competitiva, la elección tecnológica debe priorizar el rendimiento, la experiencia de usuario y la facilidad de contribución.

\textbf{Flutter} se perfila como una opción muy sólida debido a su rendimiento gráfico superior, la consistencia multiplataforma que facilita el mantenimiento por parte de una comunidad FOSS, y un ecosistema maduro con el respaldo de Google.

\textbf{React Native} es una alternativa viable, especialmente si el equipo de desarrollo tiene una fuerte experiencia en JavaScript. Su principal ventaja es el vasto ecosistema de bibliotecas y una mayor flexibilidad para integraciones nativas específicas.

\textbf{PWA} se descarta por su rendimiento inferior en tareas intensivas y las limitaciones en el acceso a las APIs nativas del dispositivo, lo que comprometería la calidad de la experiencia de usuario en una aplicación de gestión de fotos.

\textbf{Lynx.js} es una opción demasiado arriesgada en este momento. Su inmadurez, la falta de comunidad y la incertidumbre sobre su futuro lo hacen una opción arriesgada para un proyecto que busca sostenibilidad a largo plazo.
Se incluye también el factor de que es una tecnología muy nueva y con algunas funcionalidades fundamentales aún en desarrollo (como puede ser el envío de archivos mediante el cliente HTTP incorporado, una implementación de navegación entre pantallas, etc.).

\subsubsection{Tecnologías no nombradas}
Otras opciones como el desarrollo nativo (Kotlin/Swift) o Kotlin Multiplatform fueron consideradas. Se descartaron principalmente por la mayor curva de aprendizaje y, en el caso de KMP, por una madurez del ecosistema aún insuficiente para un proyecto de esta envergadura, a pesar de sus prometedoras capacidades para compartir código de forma nativa.
