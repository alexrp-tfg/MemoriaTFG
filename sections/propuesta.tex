\newpage
~
\newpage
\chapter{Propuesta}
Dado que se trata de un TFG de desarrollo, se describe lo realizado, el procedimiento seguido y los resultados obtenidos.

Una vez analizado el estado del arte y las tecnologías disponibles, se propone una propuesta a desarrollar que busca cumplir con los objetivos planteados en la introducción. Para el desarrollo de la propuesta se utilizan metodologías ágiles y tecnologías modernas para garantizar un desarrollo eficiente y que permitirá una fácil adaptación a los cambios que puedan surgir durante el desarrollo del proyecto.

Tal como se ha especificado en los capítulos anteriores, se desarrollará una solución que busca ofrecer:
\begin{itemize}
    \item Solución FOSS que permita aportar al proyecto de manera sencilla, facilitando entender el código y la arquitectura del sistema, consiguiendo de esta manera que sea más fácil contribuir al proyecto.
    \item Soluciones eficientes y rápidas. Para ello se emplearán tecnologías lo más eficientes posibles, siempre buscando la seguridad y escalabilidad de la aplicación.
    \item Solución escalable y mantenible. Se busca que la solución sea escalable y mantenible a largo plazo, permitiendo añadir nuevas funcionalidades y mejoras de manera sencilla. Para ello se implementará una arquitectura limpia \parencite{uncle-bob-clean-architecture}, lo que proporcionará una estructura del proyecto completamente desacoplada, facilitando la escalabilidad y mantenimiento.
    \item Almacenamiento eficiente. Se busca que el almacenamiento de los archivos sea lo más eficiente posible, tanto en términos de espacio como de velocidad de acceso.
        Para ello, primero se hará uso de un sistema de almacenamiento de objetos compatible con \gls{s3}, lo que permitirá utilizar cualquier servicio de almacenamiento compatible con el mismo protocolo como Google Cloud Storage o usando software libre como podría ser \gls{minio}.
        Dada la naturaleza de este proyecto, se utilizará MinIO como solución para el almacenamiento, ya que nos va a permitir almacenar nuestros archivos de manera eficiente en nuestro propio servidor.
        En una ampliación futura se valorará la implementación de una solución de almacenamiento nativa que permita un acceso más rápido y eficiente a los archivos, además de una mejor gestión de los mismos.
    \item Desarrollo ágil y flexible. Se busca que el desarrollo sea ágil y flexible, permitiendo adaptarse a los cambios y necesidades del proyecto de manera rápida y eficiente. Para ello se hará uso de la metodología ágil Scrum, lo que facilitará una organización clara del proyecto y una planificación adecuada de las tareas a realizar.
        Seguir esta metodología favorecerá una mejor organización del proyecto y una planificación adecuada de las tareas a realizar, lo que aportará una buena organización en caso de que se incorporen más personas al proyecto en el futuro.
\end{itemize}

\section{Aportaciones del proyecto al estado del arte}
Una vez realizado un estudio de las soluciones existentes y posibles tecnologías a utilizar en el capítulo \ref{ch:estado_del_arte}, se han identificado una serie de factores que pueden ser mejorados o que no están presentes en las aplicaciones actuales. Estos factores son fundamentales para ofrecer una solución más completa y eficiente en la gestión de fotos y archivos multimedia.

Nuestro proyecto busca abordar las limitaciones actuales de las aplicaciones de fotos, especialmente en términos de rendimiento, usabilidad, facilidad de aportación al proyecto y características avanzadas.
\subsection{Rendimiento}
El rendimiento es un aspecto crítico en las aplicaciones de fotos, especialmente cuando se manejan grandes colecciones. Muchas aplicaciones existentes sufren de lentitud en la carga y visualización de imágenes, lo que afecta negativamente la experiencia del usuario.
No solo se busca optimizar la carga de imágenes en la aplicación, sino mejorar la velocidad de respuesta que ofrece el servidor a la hora de recibir, procesar y responder a las peticiones de los usuarios.

Todo esto se logrará mediante el uso de tecnologías modernas, eficientes y seguras.
Se desarrollará el proyecto haciendo uso de una arquitectura estandarizada y modular, lo que permitirá una mayor flexibilidad y escalabilidad. Además, se implementarán técnicas de optimización de rendimiento, como la carga diferida de imágenes, el uso de miniaturas y la indexación eficiente de metadatos.
\subsection{Contribución al proyecto}
Nuestro proyecto no solo se centrará en ofrecer una aplicación de fotos, sino que también se diseñará como un proyecto FOSS, lo que permitirá a la comunidad contribuir y mejorar la aplicación de manera continua.

Para ello se hará uso de las mejoras prácticas de desarrollo de software:
\begin{itemize}
    \item Uso de control de versiones (\Gls{git}), documentación clara y accesible, y un proceso de revisión de código que fomente la colaboración y la calidad del código.
    \item Se implementará una estructura de proyecto que facilite la incorporación de nuevos desarrolladores, con guías claras sobre cómo contribuir y estándares de codificación.
    \item Uso de un lenguaje de programación moderno y seguro, que permita aportaciones de manera segura y eficiente.
    \item Implementación de pruebas unitarias y de integración para asegurar la calidad del código y la funcionalidad de la aplicación.
\end{itemize}

\section{Metodología}
\label{sec:metodologia}

Para el desarrollo de este proyecto se ha optado por la metodología ágil Scrum. Esta metodología se basa en el desarrollo iterativo e incremental, lo que permite una mayor flexibilidad y adaptación a los cambios durante el proceso de desarrollo.

La elección de Scrum sobre otras metodologías ágiles como Kanban o XP (Extreme Programming), o incluso enfoques tradicionales, se fundamenta en la experiencia previa del equipo de desarrollo con este marco de trabajo, lo que garantiza una mayor comodidad y eficacia en su aplicación.
Además, Scrum es una metodología que se adapta muy bien a proyectos de desarrollo de software, ya que permite una mayor flexibilidad y adaptación a los cambios durante el proceso de desarrollo.

Tal y como se explica en la guía oficial de Scrum \parencite{scrum-guide}, Scrum es un marco de trabajo ágil que se utiliza para gestionar proyectos complejos y adaptarse a los cambios de manera rápida y eficiente. Se basa en la colaboración entre equipos multidisciplinarios, la entrega continua de valor y la mejora continua.
Scrum se centra en la entrega de incrementos de producto funcionales en ciclos cortos, lo que permite a los equipos recibir retroalimentación temprana y ajustar su enfoque según sea necesario. Esto es especialmente útil en proyectos donde los requisitos pueden cambiar con frecuencia o donde la incertidumbre es alta.

Scrum se basa en una serie de roles, eventos y artefactos que ayudan a los equipos a organizar su trabajo y colaborar de manera efectiva. Los roles incluyen el Product Owner (responsable de la visión del producto), el Scrum Master (facilitador del proceso) y el equipo de desarrollo (responsable de la entrega del producto). Los eventos incluyen las reuniones diarias, las revisiones de sprint y las retrospectivas, que permiten a los equipos reflexionar sobre su trabajo y mejorar continuamente.

Aunque Scrum está muy enfocado a equipos, también es posible utilizarlo con un equipo muy pequeño o incluso con una sola persona, realizando los mismos eventos pero sin la necesidad de tener un equipo de desarrollo.
Éste es el enfoque que se le va a dar a este proyecto. Una buena práctica de Scrum es documentar todas las reuniones y tomas de decisiones que se toman a lo largo de la vida del proyecto, ya que esto ayuda a tener una mejor organización y a poder ver cómo ha ido evolucionando el proyecto a lo largo del tiempo.
Es por ello que se van a documentar todas las decisiones que se tomen y los cambios que se realicen en el desarrollo.


\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{assets/scrum-diagram.png}
  \caption{Diagrama del proceso completo de Scrum \parencite{scrum-diagram}}
  \label{fig:scrum-diagram}
\end{figure}

En esta imagen se muestra todo el proceso que se sigue con una metodología Scrum, desde la planificación del producto hasta la entrega del mismo.

Como se comenta en la guía de Scrum y se puede ver en la imagen, durante el desarrollo del proyecto se van a generar varios artefactos:
\begin{itemize}
    \item \textbf{Product Backlog}: es una lista priorizada de requisitos o tareas pendientes en un proyecto ágil. En este caso, el product backlog se va a utilizar para organizar todas las historias de usuario e historias técnicas que se van a implementar en el proyecto.
    \item \textbf{Sprint Backlog}: es una lista de tareas (las cuales salen de las historias de usuario y técnicas) seleccionadas del product backlog que se van a realizar durante un sprint.
    \item \textbf{Incremento}: es la suma de todos los elementos del product backlog completados durante un sprint y los incrementos de todos los sprints anteriores. En este caso, el incremento se va a utilizar para organizar todas las tareas que se han realizado durante cada sprint.
\end{itemize}
Aunque el producto sufra cambios después, intentar estimar lo mejor posible y terminar los sprints con un producto con \textbf{valor} es el objetivo principal de esta metodología, tal y como se dice en la guía `\textit{A product is a vehicle to deliver value. It has a clear boundary, known stakeholders, well-defined users or customers. A product could be a service, a physical product, or something more abstract.}' (\cite{scrum-guide}, apartado de Product Backlog)

Se separará el desarrollo en distintos sprints, cada uno de ellos con una duración de dos semanas.

Durante cada sprint se seleccionarán las historias de usuario\footnote{Las historias de usuario son descripciones concisas y sencillas de una funcionalidad, escritas desde la perspectiva del usuario} al principio del sprint y se desarrollarán (posible desglose en distintas historias de usuario, definición de tareas relacionadas con la HU junto con estimación de las mismas y definición de pruebas de aceptación) generando así el Sprint Backlog correspondiente a ese sprint, se completarán las tareas necesarias para completarlas.

Al final del sprint se realizará una revisión en la que se analizará lo que se ha conseguido hacer y si se ha cumplido con lo definido antes del sprint para adaptar el product backlog si fuera necesario y tenerlo en cuenta para el siguiente sprint. En la revisión participarán Product Owner, equipo de desarrollo, Scrum Master y los interesados en el proyecto (Stakeholders). Aquí es donde se presenta el incremento del producto a los interesados y se recibe retroalimentación sobre el trabajo realizado.

Y por último se lleva a cabo una retrospectiva en el equipo, donde se reflexiona principalmente sobre el modo de trabajo, los aspectos positivos, negativos y las posibles mejoras para el siguiente sprint. Esto es una parte fundamental de Scrum, ya que permite al equipo aprender de su experiencia y mejorar continuamente.

Gracias a esta metodología se consigue tener una organización muy clara de lo que se va a hacer, cómo se va a hacer y cuándo se va a hacer.

\section{Sprint 0}
\label{sec:planificacion-inicial}
Durante un desarrollo con Scrum, tal como se ha comentado anteriormente en la \hyperref[sec:metodologia]{sección de metodología}, se usan \textbf{sprints} para dividir el desarrollo en partes organizadas y planificadas con anterioridad, las cuales tienen un inicio y un fin.

Se suele crear un sprint denominado como ``Sprint 0'' en el que se hace una planificación inicial, se genera la que va a ser la primera versión del product backlog y se dan unas estimaciones de las tareas que se van a realizar en todos los sprints.
Durante este sprint no se va a desarrollar funcionalidad, si no que se van a asentar unas bases para todo el proyecto sobre las cuales se trabajará en los siguientes sprints.
Los objetivos de este sprint son los siguientes:

\begin{itemize}
    \item Definir diagrama de la arquitectura inicial del sistema.
    \item Estudiar la estructura de implementación del sistema.
    \item Definir un presupuesto para el proyecto (sección \hyperref[sec:presupuesto]{Presupuesto}).
    \item Definir el product backlog inicial (sección \hyperref[sec:historias-de-usuario]{Historias de usuario}).
    \item Estudiar documentación y cursos de las tecnologías de backend que se van a utilizar.
    \item Estudiar la documentación sobre las tecnologías de frontend que se van a utilizar.
    \item Definir el entorno de desarrollo tanto para el servidor como el cliente.
    \item Definir el backlog de el primer sprint.
    \item Realizar diagrama de Gantt para el primer sprint.
\end{itemize}

El product backlog inicial se ha definido en la \hyperref[sec:historias-de-usuario]{sección de historias de usuario} y se ha dividido en dos partes, una para el servidor y otra para el cliente móvil.

\subsection{Historias de usuario / Historias técnicas}
\label{sec:historias-de-usuario}
En esta sección se detallan las historias de usuario e historias técnicas de la aplicación, separadas en dos grupos: las de la aplicación de servidor y las de móvil.

Se ha considerado esta separación ya que la aplicación de servidor tiene un objetivo diferente al de la aplicación móvil, de esta manera conseguimos una mejor organización de las historias de usuario.

Durante los primeros sprints se trabajará de manera principalmente separada, enfocándose en la parte correspondiente que se defina de la aplicación y en una fase más avanzada se trabajará de manera conjunta, integrando ambas aplicaciones. Se realizará de esta manera para para poder enfocarnos mejor en una sola parte del proyecto, de esta manera no tenemos que estar cambiando de contexto constantemente entre las dos aplicaciones, lo que podría hacer que el desarrollo fuera más lento y tedioso.

Para la planificación del desarrollo se han utilizado puntos de historia (PH), los cuales representan una estimación de lo que se considera que se tardará en implementar las historias de usuario. Esta estimación es relativa, es decir, no representa un tiempo real sino una estimación con respecto a todas las demás historias de usuario, siendo 1 punto de historia la historia de usuario más sencilla de implementar o que menos tiempo requiere.

Este es un listado inicial de historias de usuario, durante los sprints se irá especificando si alguna historia de usuario ha cambiado, añadido o eliminado del product backlog\footnote{El product backlog es una lista priorizada de requisitos o tareas pendientes en un proyecto ágil.}.

Cada historia de usuario tiene un identificador único, una descripción de la historia de usuario y una estimación en puntos de historia. Ésta es después desglosada en historias de usuario más pequeñas de las cuales se definen tareas que tienen que ser realizadas para completar la historia de usuario con su estimación en horas.
Además de las historias de usuario, contamos con historias técnicas, que son historias de usuario que no están relacionadas directamente con el usuario final, sino que son necesarias para el correcto funcionamiento del sistema. Estas historias técnicas se consideran como historias de usuario y se les asigna una estimación en puntos de historia.

A lo largo del product backlog  se hará referencia a HU\{identificador\} para las historias de usuario y HT\{identificador\} para las historias técnicas. El identificador será un número entero que se asignará de manera consecutiva a cada historia de usuario o historia técnica. Para la sub-historias de usuario se asignará un número entero que será el mismo que la historia de usuario a la que pertenece, seguido de un punto y otro número entero que será el identificador de la sub-historia de usuario, por ejemplo: HU1, HU1.1, HU1.2, etc.

\paragraph{Servidor}
\renewcommand{\arraystretch}{1.3} % Increases row height for readability
\rowcolors{2}{gray!15}{white} % Alternate row colors

\begin{tabularx}{\textwidth}{|l|l|>{\raggedright\arraybackslash}X|l|}
    \hline
\textbf{ID} & \textbf{Título} & \textbf{Descripción} & \makecell{\textbf{Estimación}\\\textbf{(PH)}} \\
    \hline
    HU01 & Subida de fotos & Como usuario, quiero subir varias fotos desde mi móvil para tener una copia de seguridad en mi servidor. & 5 \\
    \hline
    HU02 & Estado de sincronización & Como usuario, quiero ver qué fotos están subidas y cuáles no, para saber el estado de sincronización. & 3 \\
    \hline
    HU03 & Eliminar fotos & Como usuario, quiero eliminar fotos subidas desde la app, para liberar espacio en mi servidor. & 3 \\
    \hline
    HU04 & Subida de vídeos & Como usuario, quiero subir vídeos además de fotos, para guardar también mis recuerdos en vídeo. & 5 \\
    \hline
    HU05 & Inicio de sesión & Como usuario, quiero iniciar sesión con contraseña o clave, para evitar que otros accedan a mis archivos. & 5 \\
    \hline
    HU06 & Cerrar sesión & Como usuario, quiero poder cerrar sesión en un dispositivo, para proteger mis datos si pierdo el móvil. & 2 \\
    \hline
    HU07 & Descubrimiento automático & Como usuario, quiero que la app detecte automáticamente mi servidor en la red local, para no tener que configurarlo manualmente. & 8 \\
    \hline
    HU08 & Conexión remota & Como usuario, quiero poder conectarme remotamente si expongo mi servidor, para acceder a mis fotos desde fuera de casa. & 13 \\
    \hline
    HU09 & Galería visual & Como usuario, quiero ver una galería de las fotos y videos subidos, para revisar mi contenido fácilmente. & 5 \\
    \hline
    HU10 & Espacio ocupado & Como usuario, quiero ver el espacio ocupado por mis archivos, para controlar el almacenamiento del servidor. & 3 \\
    \hline
    HU11 & Estadísticas de copia & Como usuario, quiero ver estadísticas de sincronización, para saber cuándo fue la última copia y cuántos archivos se han guardado. & 3 \\
    \hline
    HU12 & Cancelar sincronización & Como usuario, quiero cancelar una sincronización en curso. & 5 \\
    \hline
    HU13 & Crear cuentas & Como administrador, quiero crear cuentas de usuario con permisos, para que varias personas puedan usar el servidor. & 8 \\
    \hline
    HU14 & Galería privada & Como usuario, quiero tener mi propia galería separada de otros usuarios. & 5 \\
    \hline
    HU15 & Galería online & Como usuario, quiero poder ver todas las fotos que tengo en el servidor sin necesidad de tener que descargarlas en mi móvil, tanto las que he subido yo como las que han compartido conmigo. & 8 \\
    \hline
    HT01 & Hash de archivos & Implementar sistema de cálculo de hash para detectar duplicados. & 3 \\
    \hline
    HT02 & Sincronización incremental & Implementar sincronización basada en metadatos (fecha, tamaño, hash). & 5 \\
    \hline
    HT03 & API REST & Desarrollar API RESTful par el servidor & 13 \\
    \hline
    HT04 & Descubrimiento mDNS & Crear sistema de descubrimiento automático usando mDNS. & 8 \\
    \hline
    HT05 & Autenticación JWT & Implementar autenticación con JSON Web Tokens. & 5 \\
    \hline
    HT06 & HTTPS en servidor & Configurar comunicación segura con HTTPS. & 5 \\
    \hline
    HT07 & Estructura de almacenamiento & Definir carpetas y metadatos para organizar los archivos. & 5 \\
    \hline
    HT08 & Base de datos & Implementar SQLite o PostgreSQL para usuarios y archivos. & 8 \\
    \hline
    HT09 & Compresión de imágenes & Implementar compresión para optimizar el almacenamiento. & 5 \\
    \hline
    HT10 & Subida concurrente & Soporte para subida simultánea y manejo de errores. & 8 \\
    \hline
    HT11 & Tests & Añadir pruebas unitarias e integración en backend. & 5 \\
    \hline
    HT12 & CI/CD & Configurar pipelines de integración y despliegue. & 5 \\
    \hline
    HT13 & Logging & Implementar logs detallados para depuración. & 3 \\
    \hline
    HT14 & Cobertura de tests & Medir y asegurar la cobertura de pruebas. & 3 \\
    \hline
    HT15 & Interfaz Tauri & Crear interfaz gráfica del servidor con Tauri. & 8 \\
    \hline
    HT16 & Panel de control & Implementar visualización de archivos y uso del sistema. & 5 \\
    \hline
    HT17 & Notificaciones de progreso & Integrar notificaciones del sistema con progreso de subida. & 3 \\
    \hline
    HT18 & Binario y Tauri & Empaquetar servidor como CLI y app Tauri. & 5 \\
    \hline
    HT19 & Dockerización & Crear imagen Docker del servidor. & 3 \\
    \hline
    HT20 & Documentación & Documentar instalación y uso del sistema. & 13 \\
    \hline
    HT21 & Backups externos & Soporte para backups automáticos externos. & 8 \\
    \hline
    HT22 & Logs persistentes & Configurar sistema de logs persistentes y rotación. & 3 \\
    \hline
\end{tabularx}

\paragraph{Historias que se han dividido}

Ambas tablas que aparecen a continuación muestran historias técnicas que han sido divididas en sub-historias para facilitar su gestión y estimación en el backlog.

\begin{table}[h!]
    \begin{center}
        \begin{tabularx}{\textwidth}{|l|l|>{\raggedright}X|l|}
            \hline
            ID & Título & Descripción & Estimación \\
            \hline
            HT18 & Binario y Tauri & Empaquetar servidor como CLI y app Tauri. & 5 \\
            \hline
            HT18.1 & Binario & Empaquetar la aplicación como un solo binario & 2 \\
            \hline
            HT18.2 & Tauri & Empaquetar aplicación de escritorio con Tauri & 3 \\
            \hline
        \end{tabularx}
    \end{center}
\end{table}

\begin{table}[h!]
    \begin{center}
        \begin{tabularx}{\textwidth}{|l|X|>{\raggedright\arraybackslash}X|l|}
            \hline
            ID & Título & Descripción & Estimación \\
            \hline
            HT20 & Documentación & Documentar instalación y uso del sistema. & 13 \\
            \hline
            HT20.1 & Documentación del proyecto en Github & Documentar la instalación y uso del proyecto en el repositorio de Github & 5 \\
            \hline
            HT20.2 &  Documentación de la API REST con OpenAPI & Documentar mediante la generación de una página web todos los endpoints de la API REST & 5 \\
            \hline
            HT20.3 & Documentación de la aplicación Tauri & Manual de usuario de la aplicación de escritorio desarrollada con Tauri & 3 \\
            \hline
        \end{tabularx}
    \end{center}
\end{table}

\newpage
\paragraph{Móvil}
\begin{tabularx}{\textwidth}{|l|l|>{\raggedright\arraybackslash}X|l|}
    \hline
    ID & Título & Descripción & Estimación \\
    \hline
    HU16 & Seleccionar fotos & Como usuario, quiero seleccionar varias fotos desde mi galería para subirlas al servidor. & 3 \\
    \hline
    HU17 & Subir fotos automáticamente & Como usuario, quiero que se suban automáticamente las nuevas fotos que hago, sin tener que hacerlo manualmente. & 8 \\
    \hline
    HU18 & Ver progreso de subida & Como usuario, quiero ver el progreso de cada archivo que se está subiendo. & 8 \\
    \hline
    HU19 & Cancelar subida & Como usuario, quiero cancelar una subida en curso desde la interfaz. & 3 \\
    \hline
    HU20 & Ver archivos subidos & Como usuario, quiero ver una lista o galería de los archivos que ya están subidos. & 5 \\
    \hline
    HU21 & Conexión automática al servidor & Como usuario, quiero que la app detecte y se conecte automáticamente al servidor en mi red. & 5 \\
    \hline
    HU22 & Cambiar de servidor & Como usuario, quiero poder cambiar manualmente la dirección del servidor si quiero usar otro. & 3 \\
    \hline
    HU23 & Ver uso de almacenamiento & Como usuario, quiero ver cuánto espacio he usado en el servidor. & 3 \\
    \hline
    HU24 & Inicio y cierre de sesión & Como usuario, quiero iniciar y cerrar sesión para proteger mis datos. & 5 \\
    \hline
    HU25 & Gestión de permisos & Como usuario, quiero que la app me pida permisos de acceso solo cuando sea necesario. & 3 \\
    \hline
    HU26 & Notificaciones de subida & Como usuario, quiero recibir notificaciones cuando se complete la sincronización. & 5 \\
    \hline
    HU27 & Subir vídeos & Como usuario, quiero subir también vídeos de mi galería al servidor. & 5 \\
    \hline
    HU28 & Subida en segundo plano & Como usuario, quiero que las subidas continúen aunque cierre la app. & 8 \\
    \hline
    HU29 & Sincronización manual & Como usuario, quiero poder iniciar la sincronización manualmente. & 3 \\
    \hline
    HU30 & Galería online & Como usuario, quiero ver mis fotos en la app sin tener que descargarlas. & 5 \\
    \hline
    HT23 & Acceso a la galería & Implementar acceso seguro a la galería de fotos y vídeos. & 5 \\
    \hline
    HT24 & Comunicación con API & Integrar cliente HTTP que se comunique con el servidor. & 5 \\
    \hline
    HT25 & Almacenamiento local & Guardar estado de archivos subidos/no subidos de forma local. & 3 \\
    \hline
    HT26 & Manejo de errores de red & Implementar gestión de errores de red y reintentos automáticos. & 5 \\
    \hline
    HT27 & Subida concurrente & Soportar subida de varios archivos en paralelo con control de errores. & 5 \\
    \hline
    HT28 & Sincronización de fondo & Implementar sincronización en segundo plano. & 8 \\
    \hline
    HT29 & Pruebas unitarias & Añadir pruebas unitarias y de integración a la lógica común en React Native / Lynx.js & 13 \\
    \hline
    HT30 & CI/CD móvil & Pipeline de construcción y publicación para Android e iOS. & 5 \\
    \hline
    HT31 & Gestión de tokens & Almacenar y renovar tokens de autenticación de forma segura. & 3 \\
    \hline
    HT32 & Notificaciones locales & Integrar sistema de notificaciones locales en Android/iOS. & 3 \\
    \hline
    HT33 & Optimización de red & Reducir uso de red usando compresión. & 5 \\
    \hline
    HT34 & Localización & Soporte multilenguaje para la aplicación. & 8 \\
    \hline
    HT35 & Permisos condicionales & Solicitar permisos en tiempo de ejecución de forma contextual. & 3 \\
    \hline
    HT36 & UI responsive & Adaptar UI para distintos tamaños de pantalla (tablet, móvil). & 3 \\
    \hline
\end{tabularx}



\subsection{Arquitectura del sistema}
\begin{figure}[H]
    \begin{center}
        \includegraphics[width=0.95\textwidth]{images/diagrama-arquitectura.png}
    \end{center}
    \caption{Diagrama de la arquitectura del sistema. Representa las comunicaciones entre los distintos elementos del sistema}\label{fig:diagrama-arquitectura}
\end{figure}

Como se muestra en la Figura \ref{fig:diagrama-arquitectura}, el sistema va a estar compuesto por un cliente (móvil tanto en Android como iOS) que se comunica con un servidor mediante peticiones HTTP.
Se estudió la posibilidad de la comunicación mediante gRPC (\textit{Google Remote Procedure Call}) pero se desechó ya que la compatibilidad entre un cliente multiplataforma móvil y el servidor de sincronización no permitía hacer uso de todas las ventajas que ofrecía frente a un método convencional como puede ser una API REST.

Todo esto hizo decidirse por una API REST, la cual es más sencilla de implementar y de mantener a largo plazo, además de ser más fácil de entender para cualquier desarrollador que quiera contribuir al proyecto.

El servidor se comunicará de manera abstracta con un servicio de almacenamiento de datos. Para la primera versión de la aplicación se hará uso de MinIO, un software Open-Source que permite crear un servidor de almacenamiento de objetos compatible con la API de Amazon S3.
Esto proporciona la ventaja de poder utilizar cualquier servicio de almacenamiento compatible con S3 como Amazon S3, Google Cloud Storage en el futuro sin necesidad de cambiar la aplicación.
MinIO está diseñado para ser totalmente escalable y de alto rendimiento, lo que lo convierte en una excelente opción para almacenar grandes volúmenes de datos, como fotos y vídeos.

Aunque en las primeras iteraciones se utilice MinIO para almacenar los datos multimedia, en iteraciones más avanzadas se implementará un sistema de almacenamiento nativo, el cual permitirá un mayor control sobre los datos y una mejor integración con el resto del sistema.

Gracias a la arquitectura limpia (\cite{uncle-bob-clean-architecture}) que se va a utilizar a la hora de implementar el sistema, se consigue un desacople total de la capa de aplicación, dominio e infraestructura, brindando la posibilidad de cambiar la implementación de la capa de infraestructura sin afectar al resto del sistema, proporcionando de esta manera flexibilidad sobre la solución que se desee usar para almacenar los datos/multimedia.

Para el almacenaje de los datos de la aplicación se ha optado por hacer uso de un \acrshort{orm} con PostgreSQL.
Aunque puede ser menos escalable comparado con otras soluciones noSQL a largo plazo, esta opción proporciona una gran cantidad de ventajas frente a las desventajas que tiene, como pueden ser:
\begin{itemize}
    \item \textbf{Integridad de los datos}: PostgreSQL es un sistema de gestión de bases de datos relacional, lo que significa que garantiza la integridad de los datos mediante el uso de transacciones y restricciones.
    \item \textbf{Escalabilidad}: aunque no es tan escalable como otras soluciones noSQL, PostgreSQL es capaz de manejar grandes volúmenes de datos y puede escalar horizontalmente mediante particionamiento.
    \item \textbf{Rendimiento}: PostgreSQL es conocido por su alto rendimiento y eficiencia en el manejo de consultas complejas y grandes volúmenes de datos.
    \item \textbf{Comunidad activa}: PostgreSQL tiene una comunidad muy activa y una gran cantidad de documentación y recursos disponibles, lo que facilita su aprendizaje y uso.
    \item \textbf{Open-Source}: al ser un software Open-Source, no es necesario pagar por licencias y se alinea con el enfoque del proyecto que busca ser Open-Source.
\end{itemize}

Aunque se elija una base de datos en este punto del proyecto, la arquitectura del sistema permite cambiar la implementación de la capa de infraestructura sin afectar al resto del sistema, lo que proporciona flexibilidad para cambiar la base de datos en el futuro si fuera necesario.
Además, se ha optado por hacer uso de un \acrshort{orm} para facilitar la interacción con la base de datos y abstraer la complejidad de las consultas SQL, lo que permite centrarse en la lógica de negocio y no en la implementación de la base de datos.
Esto otorga mayor flexibilidad a la hora de cambiar la base de datos en el futuro, ya que el \acrshort{orm} permite cambiar el motor de base de datos fácilmente.

Una de las principales fortalezas del sistema propuesto radica en su escalabilidad horizontal, facilitada por la arquitectura distribuida de sus componentes principales. La separación del servidor de aplicación, el sistema de almacenamiento de archivos (MinIO) y la base de datos (PostgreSQL) en componentes independientes permite escalar cada uno de manera selectiva según las demandas específicas del sistema, sin comprometer la disponibilidad ni la integridad de los datos.

En el caso del servidor de aplicación, se pueden desplegar múltiples instancias detrás de un balanceador de carga que distribuya las peticiones de manera inteligente. Esto no solo mejora el rendimiento al procesar más peticiones simultáneamente, sino que también proporciona alta disponibilidad: si una instancia falla, el balanceador redirige automáticamente el tráfico a las instancias restantes, garantizando que los usuarios no experimenten interrupciones en el servicio. La naturaleza \textit{stateless} del servidor facilita esta escalabilidad, ya que cualquier instancia puede procesar cualquier petición sin dependencia de estado local.

Para el almacenamiento de archivos multimedia, MinIO ofrece capacidades de escalabilidad horizontal nativas mediante clustering y distribución automática de datos. Se pueden añadir nuevos nodos al cluster de MinIO de manera transparente, aumentando tanto la capacidad de almacenamiento como el rendimiento de lectura/escritura. La replicación automática de objetos entre nodos garantiza la disponibilidad de los datos incluso durante operaciones de mantenimiento o fallos de hardware. Los usuarios continúan accediendo a sus archivos sin interrupciones, mientras que el sistema redistribuye automáticamente la carga entre los nodos disponibles.

En cuanto a PostgreSQL, la escalabilidad se puede abordar mediante varias estrategias complementarias. Para escalado de lectura, se pueden implementar réplicas de solo lectura que manejen consultas de visualización de galerías y metadatos, mientras que el servidor principal gestiona las operaciones de escritura. Para cargas más intensivas, se puede implementar particionamiento horizontal (sharding) donde los datos se distribuyen entre múltiples instancias según criterios como el ID de usuario o la fecha de creación. Adicionalmente, el uso de técnicas como connection pooling y caché distribuido (Redis/Memcached) reduce la carga en la base de datos y mejora los tiempos de respuesta.

El diseño modular del sistema permite que estas operaciones de escalado se realicen sin impacto en la experiencia del usuario mediante la implementación de estrategias de despliegue avanzadas. El \textit{blue-green deployment} consiste en mantener dos entornos idénticos de producción: mientras el entorno "azul" atiende a los usuarios, el entorno "verde" se actualiza con las nuevas instancias o configuraciones. Una vez verificado que el entorno verde funciona correctamente, se redirige todo el tráfico instantáneamente, eliminando tiempos de inactividad. Alternativamente, los \textit{rolling updates} permiten actualizar gradualmente las instancias del servidor una por una, manteniendo siempre un número mínimo de instancias operativas para atender las peticiones mientras las demás se actualizan secuencialmente.

Para garantizar la resistencia ante fallos temporales durante estos procesos, el cliente móvil implementa mecanismos de \textit{retry automático}, que consiste en reintentar automáticamente las peticiones fallidas después de intervalos exponencialmente crecientes (por ejemplo, 1s, 2s, 4s, 8s), permitiendo que operaciones como la subida de fotos se completen exitosamente incluso si algunos servidores están temporalmente no disponibles.

Esta arquitectura distribuida no solo facilita el crecimiento del sistema, sino que también mejora su resistencia a fallos, asegurando que los usuarios puedan acceder a sus fotos y sincronizar nuevos archivos de manera continua, independientemente de las operaciones de infraestructura que se estén realizando en segundo plano. La combinación de estas estrategias garantiza que el escalado del sistema sea completamente transparente para el usuario final, manteniendo la integridad de los datos y la continuidad del servicio en todo momento.

\subsection{Arquitectura software}
En un proyecto de este tipo es muy importante tener una buena estructura a la hora de diseñar el software.
Se busca la separación de responsabilidades y una buena organización, lo cual satisface uno de los objetivos específicos (OE5): desarrollar un sistema que sea fácilmente escalable.

Para ello, se han estudiado las distintas opciones disponibles, tanto para el servidor como para la aplicación móvil, y se ha optado por una variación de la arquitectura limpia \parencite{uncle-bob-clean-architecture}, cuyos principios son:
\begin{itemize}
    \item \textbf{Separación de responsabilidades}: cada capa del sistema tiene una responsabilidad clara y bien definida, lo que facilita el mantenimiento y la evolución del sistema.
    \item \textbf{Independencia de la infraestructura}: las capas más internas del sistema no dependen de detalles de implementación de la infraestructura, lo que permite cambiar la infraestructura sin afectar al resto del sistema.
    \item \textbf{Facilidad de pruebas}: al tener una separación clara de responsabilidades, es más fácil realizar pruebas unitarias e integración, lo que mejora la calidad del software.
    \item \textbf{Escalabilidad}: al estar desacopladas las distintas capas del sistema, es más fácil escalar el sistema a medida que crece.
\end{itemize}

\paragraph{Arquitectura del servidor}
\subparagraph{}
Para el servidor se ha decidido usar una estructura monolítica modular siguiendo los principios de una arquitectura limpia.
Este enfoque se acerca a lo que sería una estructura de microservicios, pero sin la complejidad que conlleva el uso de múltiples servicios.
Siguiendo esta solución la aplicación se compone de un solo binario que contiene todo el código del servidor, pero con una estructura modular donde cada módulo tiene una responsabilidad clara y bien definida.
Es la mejor solución para un equipo pequeño ya que se elimina el factor de la comunicación entre distintos servicios, el despliegue de los mismos y la gestión de la infraestructura para cada uno de los servicios.

Aun así, cuenta con la gran mayoría de las ventajas que proporciona una arquitectura de microservicios, como la separación de responsabilidades, la facilidad de pruebas y la escalabilidad.
De esta manera, en un futuro se podría separar el servidor en microservicios de manera sencilla, dado que se dispone de una estructura modular donde cada módulo tiene su responsabilidad, por lo que tan solo sería necesario separar los módulos en distintos servicios y hacer que se comuniquen entre ellos mediante un protocolo de comunicación específico, como puede ser HTTP o gRPC.


\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{assets/modular-monolith-comparison.png}
  \caption{Comparativa entre una arquitectura monolítica, de microservicios y monolítica modular. \parencite{tsechelidis2023modular}}
  \label{fig:modular-monolith-comparison}
\end{figure}

En la Figura \ref{fig:modular-monolith-comparison} se muestra que la diferencia entre una arquitectura de microservicios y una monolítica modular es que los módulos comparten el mismo proceso y por ende la comunicación entre ellos cambiará y se hará de manera local mediante llamadas a funciones, mientras que en una arquitectura de microservicios la comunicación entre los distintos servicios se hace mediante peticiones a través de un protocolo de comunicación específico y cada módulo tendría su propia forma de administrar datos, lo que añade una capa de complejidad innecesaria para un proyecto de este alcance.

\paragraph{Arquitectura del cliente}
\subparagraph{}
La aplicación móvil también seguirá una arquitectura limpia, la cual contará con una capa de presentación, una capa de dominio y una capa de infraestructura.
La capa de presentación se encargará de la interfaz de usuario y de la interacción con el usuario, la capa de dominio se encargará de la lógica de negocio y la capa de infraestructura se encargará de la comunicación con el servidor y el almacenamiento local.

Tal como se comenta en el libro \textit{Clean Architecture} \parencite{uncle-bob-clean-architecture}, esta arquitectura es como una cebolla, donde cada capa está separada por una interfaz y cada capa puede comunicarse con la capa inferior a través de esta interfaz, pero no al revés.
Es decir, la capa de dominio no se puede comunicar con ninguna de las otras capas, ya que esta es la capa más interna y no debe depender de ninguna otra capa.


\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{assets/clean-architecture-mobile.png}
  \caption{Diagrama de arquitectura limpia en aplicación móvil.}
  \label{fig:clean-architecture-mobile}
\end{figure}

Las flechas representan cómo accede cada capa a las demás.
El acceso se hace de la capa más externa a la más interna, es decir, la capa de dominio (la más interna) no puede saber nada sobre las otras capas, pero la capa de presentación puede acceder a la capa de dominio y a la capa de aplicación.

La capa de aplicación no utiliza directamente la capa de infraestructura, sino que lo hace a través de interfaces definidas en la capa de dominio. La capa de infraestructura se encarga de implementar estas interfaces, lo que permite cambiar la implementación de la capa de infraestructura sin afectar a la capa de dominio, de aplicación ni la de presentación.

De esta manera se consigue una separación de responsabilidades y una independencia de la infraestructura, lo que permite cambiar la implementación de cualquier capa sin afectar al resto del sistema.
También permite hacer pruebas unitarias e integración de manera más sencilla, ya que permite \gls{mockear} las interfaces de la capa de infraestructura y probar la lógica de negocio sin necesidad de depender de la implementación concreta de la capa de infraestructura.

\subsection{Desarrollo de artefactos del primer sprint}
Tal y como se ha definido en la \hyperref[sec:metodologia]{sección de metodología}, cada sprint se va a enfocar en una parte del proyecto. En este caso, el primer sprint se va a centrar en historias de usuario del servidor solamente. El segundo sprint se centrará en las historias de usuario del cliente móvil y una vez analizado el estado de ambos productos, se decidirá si comenzar a tener sprints conjuntos.

En la metodología Scrum se seleccionan historias de usuario hasta que la suma de las estimaciones de las historias de usuario sea menor o igual a la velocidad del equipo para ese sprint.
La velocidad del equipo se define como la cantidad de puntos de historia que el equipo puede completar en un sprint, y se calcula a partir de los sprints anteriores.
En este caso, como es el primer sprint y no hay una velocidad definida, se escogen historias de usuario fijándose en el tipo de tarea e intentando no tener una suma de puntos de historia muy alta.

Una vez se termina el sprint, en el proceso de retrospectiva se analiza cuántas historias de usuario se han completado o cuantas se han quedado a medias, y se ajusta la velocidad del equipo para el siguiente sprint. Este proceso se repite en cada sprint hasta que el equipo tiene una velocidad estable y se puede obtener una estimación más precisa de cuántas historias de usuario pueden completarse en cada sprint.

Durante la especificación del sprint backlog se va a estudiar si hay historias de usuario que puedan ser divididas en distintas historias y una vez se hayan definido las historias de usuario que se van a implementar en el sprint, se definirán las tareas correspondientes a cada historia de usuario junto con su estimación en horas.
En el momento que se disponga de estimaciones en horas de tareas, es posible realizar un diagrama de Gantt para el sprint con las tareas y su duración estimada.

\subsection{Planificación de entregas}
En esta sección se va a definir los objetivos generales que tendremos para cada entrega en caga sprint. Estos objetivos son estimados y pueden variar dependiendo de la velocidad real del equipo, puede ser que se consiga más en un sprint o menos. Esta planificación se realiza para que, en el caso de que tuviéramos un cliente, se le pudiera dar una estimación del producto que va a ir recibiendo en cada entrega.

En este caso y en este tipo de proyecto, sirve para tener un enfoque claro de lo que se quiere conseguir en cada sprint y no desviarse realizando otras tareas.
Definir qué se va a entregar en cada sprint también ayudará priorizar qué historias de usuario se van a realizar en cada sprint.

Para el desarrollo de este proyecto teniendo en cuenta las historias de usuario definidas en el backlog, se han definido 6 sprints de 2 semanas cada uno, lo que da un total de 12 semanas de desarrollo.

Los objetivos de cada sprint quedarían de la siguiente manera:
\begin{itemize}
    \item \textbf{Sprint 1}: Implementación de la API REST del servidor, incluyendo la gestión de usuarios, autenticación y autorización. Durante esta iteración se busca implementar una gestión de usuarios simple junto con toda la estructura base del proyecto.
    \item \textbf{Sprint 2}: Implementación de la aplicación móvil. Definición e implementación de módulos nativos para el acceso a archivos multimedia y permisos. Durante esta iteración se busca implementar una aplicación de gestión de galería básica sin funcionalidades de sincronización.
    \item \textbf{Sprint 3}: Implementación de todo el procesado multimedia en el servidor: generación de miniaturas, subida y compresión de imágenes y vídeos, etiquetado basado en metadatos, etc. En el cliente se implementará la subida de archivos multimedia a el servidor y la visualización de los archivos subidos.
    \item \textbf{Sprint 4}: Implementación de la sincronización automática de archivos multimedia en el cliente móvil tanto como la visualización del estado de la galería en el servidor. En esta iteración se implementará principalmente toda la conexión automática entre el cliente y el servidor, así como la sincronización de archivos multimedia.
    \item \textbf{Sprint 5}: Implementación de la gestión de usuarios desde el cliente móvil, incluyendo la gestión de permisos en las galerías, álbumes y archivos. Durante esta última iteración se implementará el uso compartido de galerías y álbumes entre usuarios.
    \item \textbf{Sprint 6}: Implementación de interfaz de usuario para gestión de configuración del servidor. Implementación de servicio de almacenamiento de archivos multimedia nativo en el servidor.
\end{itemize}
Este último sprint, aunque no entra en el plazo de entrega del proyecto, se define para tener una idea de lo que se quiere conseguir en el futuro, poder tener una planificación más clara de lo que se quiere conseguir en el proyecto y facilitar contribuciones al proyecto open-source.

Tal y como se ha mencionado anteriormente, estos objetivos son estimados y por la naturaleza de la metodología Scrum pueden ir variando a lo largo del desarrollo. Al final de cada sprint se realizará una retrospectiva donde se ajustarán los backlogs y objetivos de los siguientes sprints en función de lo que se haya conseguido en el sprint anterior.

\section{Tecnologías}
Una vez realizado el análisis de las distintas tecnologías que se pueden utilizar para el desarrollo del proyecto en el Capítulo \ref{sec:tecnologias} y definidos los objetivos principales del proyecto (sección \ref{sec:objetivos}), se ha decidido utilizar las siguientes tecnologías para cada parte del proyecto:

\subsection{Servidor}
Para el servidor, cualquiera de las dos soluciones sería completamente válida. Go podría ser la mejor opción por su enfoque en la simplicidad y la facilidad de uso, especialmente para aplicaciones web y servicios de red. Sin embargo, Rust ofrece ventajas significativas en términos de seguridad de memoria y rendimiento, lo que lo convierte en una opción atractiva para aplicaciones que requieren alta concurrencia y eficiencia.

En este proyecto se busca alto rendimiento, seguridad, facilidad de contribuir al proyecto y un lenguaje sólido que no sea propenso a fallos.
Es por esto que Rust es la mejor opción para este caso. \parencite{rust-for-safety-and-performance}

Tal como se ha comentado anteriormente, Rust facilita la seguridad en la ejecución del código gracias a su estricto compilador.
Ofrece una gran variedad de funcionalidades sin coste en rendimiento junto con su sistema de propiedad y préstamos que permite gestionar la memoria de forma segura y eficiente, evitando errores comunes como las condiciones de carrera o los punteros nulos sin necesidad de un recolector de basura (\acrfull{gb}).

Aunque la curva de aprendizaje de Rust es más pronunciada, los beneficios a largo plazo en términos de seguridad y rendimiento justifican esta inversión inicial.

Invertir en aprender este lenguaje no solo favorecerá el desarrollo de este proyecto, sino que también proporcionará habilidades valiosas para futuros proyectos en el ámbito del desarrollo de software, el cual al final es uno de los objetivos de hacer un proyecto de este tamaño.

El trabajo con tecnologías y paradigmas de programación poco familiares para el equipo contribuye al desarrollo de nuevas competencias y a la ampliación del conocimiento en el ámbito del desarrollo de software, lo cual resulta fundamental para el crecimiento profesional.

Para la parte de servidor se va a hacer uso de uno de los lenguajes más venerados en la actualidad en el mundo de la programación: \textbf{Rust}.

Rust es un lenguaje de programación de sistemas que se centra en la seguridad, el rendimiento y la concurrencia. Se ha convertido en una opción popular para el desarrollo de aplicaciones de alto rendimiento y sistemas críticos.
Aunque Rust es un lenguaje de bajo nivel, su sintaxis es muy similar a la de otros lenguajes de programación como C++ o Java, lo que facilita su aprendizaje para los programadores que ya tienen experiencia en estos lenguajes, permitiendo un desarrollo más seguro, rápido y eficiente.

\begin{itemize}
    \item \textbf{Rendimiento}: es conocido por su alto rendimiento, lo que lo convierte en una excelente opción para aplicaciones que requieren un procesamiento intensivo de datos. Aunque es un lenguaje enfocado a sistemas, el rendimiento de sus librerías para desarrollo web es muy bueno, como se puede ver en distintos benchmark \parencite{rust-benchmark}.
    \item \textbf{Seguridad}: tiene un sistema de tipos y un modelo de propiedad que ayudan a prevenir errores comunes de programación, como desbordamientos de búfer y condiciones de carrera.
    \item \textbf{Concurrencia}: soporta de manera nativa y sencilla la escritura de código concurrente y paralelo, lo que es esencial para aplicaciones que manejan múltiples tareas al mismo tiempo.
        Gracias a su implementación de \gls{fearless-concurrency}, Rust permite a los desarrolladores escribir código concurrente sin preocuparse por errores comunes como condiciones de carrera o deadlocks, lo que facilita la creación de aplicaciones altamente eficientes y escalables.
    \item \textbf{Manejo de errores}: tiene un enfoque único para el manejo de errores, utilizando tipos de datos como \texttt{Result} y \texttt{Option} para representar resultados exitosos y fallidos, lo que ayuda a evitar errores en tiempo de ejecución, consiguiendo de esta manera no encontrarnos con errores inesperados a la hora de ejecutar la aplicación.
    \item \textbf{Ecosistema}: cuenta con un ecosistema en crecimiento, con una amplia variedad de bibliotecas y herramientas que facilitan el desarrollo de aplicaciones.
\end{itemize}


Para el desarrollo de el servidor de sincronización se ha decidido usar del framework de aplicaciones web \href{https://github.com/tokio-rs/axum?tab=readme-ov-file}{\textbf{Axum}}.
Axum es un framework de aplicaciones web construido sobre Tokio, una biblioteca de programación asíncrona para Rust. Axum se centra en la simplicidad y la facilidad de uso, lo que lo convierte en una excelente opción para desarrollar aplicaciones web rápidas y eficientes.
Aunque hay varios frameworks más eficientes en términos de velocidad a la hora de realizar benchmarks\footnote{\href{https://web-frameworks-benchmark.netlify.app/result?l=rust}{Comparativa frameworks de Rust}} \footnote{\href{https://www.techempower.com/benchmarks/\#section=data-r21&test=composite&hw=ph}{Comparativa con frameworks de otros lenguajes}}, algunos de ellos tienen un tiempo de compilación demasiado alto, por lo que puede llegar a hacer más lento el desarrollo.
Además, ninguno de los demás frameworks de Rust tiene una comunidad tan activa como la de Axum ni una documentación tan completa.

Axum al estar desarrollado sobre la librería de Tokio\footnote{Librería de Rust más usada para la programación asíncrona}, garantiza un soporte a largo plazo que otros frameworks no garantizan. Además, es \href{https://lib.rs/crates/axum}{la librería más descargada }mensualmente para aplicaciones web en Rust.

Como se puede ver en los benchmark hay frameworks de otros lenguajes que pueden parecer más sencillos que Rust y que ofrecen el mismo o mejor rendimiento, pero como se ha comentado anteriormente, el punto principal de Rust no es únicamente su rendimiento, sino la seguridad que proporciona el propio lenguaje y lo poco propenso que es a errores en tiempo de compilación, lo que hace que la aplicación sea mucho más robusta, segura y sostenible a largo plazo.


\subsection{Aplicación Móvil}
Para el desarrollo de la aplicación móvil se ha optado por el nuevo framework de desarrollo multiplataforma, \textbf{Lynx.js}.

Esta es una opción muy arriesgada para este proyecto ya que es un framework que aún está en desarrollo y no tiene una comunidad tan grande como otros frameworks más consolidados como React Native o Flutter.

Trabajar con un framework que aún está en desarrollo y que tiene muchas funcionalidades por implementar puede parecer arriesgado, pero también ofrece la oportunidad de contribuir al desarrollo del framework y ayudar a mejorar la herramienta para el futuro.
El hecho de que no haya un punto de partida tan avanzado como en otros frameworks hará que el equipo tenga que enfrentarse a retos y problemas que no se han resuelto aún, lo que puede ser una gran oportunidad para aprender y mejorar las habilidades de desarrollo.
Desarrollar ese tipo de funcionalidades en un framework conseguirá que el equipo tenga un conocimiento más profundo de cómo funciona el framework y cómo se pueden implementar soluciones eficientes y efectivas.

Lynx.js es un framework inspirado en React Native. El desarrollo de la aplicación se hace con React el cual se compila a código nativo de la plataforma. El framework soporta componentes de cualquier framework de desarrollo web, aunque está pensado para usar React con componentes definidos por el framework de desarrollo.

Aunque pueda parecer igual que React Native, Lynx añade algunas cosas que le faltan a React Native. Uno de los mayores problemas de React Native es su rendimiento en algunas situaciones, ya que este solamente hace uso de un solo hilo de ejecución, lo cual no permite una buena gestión de las tareas. Por ejemplo, no puede obtener datos de una API mientras que se actualiza lo que se muestra al usuario.

Sin embargo, Lynx tiene se ejecuta sobre dos hilos, un hilo principal y un hilo secundario.
Gracias a esto, es posible especificar en qué hilo se va a ejecutar cada función, consiguiendo de esta manera que tareas como mostrar rápidamente la interfaz se hagan lo más rápido posible mientras que en el hilo secundario se obtienen los datos de la API.
Esto da una experiencia al usuario mucho más fluida y rápida, principalmente gracias a el \gls{ifr} (\acrshort{ifracr}).

Para conseguir esto, Lynx altera el ciclo de vida de los componentes de React (figura \ref{fig:lynx-component-lifecycle}), consiguiendo deshacerse de cuellos de botella típicos que aparecen en los frameworks de desarrollo móvil asegurando un rendimiento óptimo y una experiencia de usuario fluida.

\begin{figure}[h]
    \begin{center}
        \includegraphics[width=\textwidth]{lynx-lifecycle.png}
    \end{center}
    \caption{Ciclo de vida de los componentes en Lynx.js (\href{https://lynxjs.org/react/lifecycle.html}{Documentación})}
    \label{fig:lynx-component-lifecycle}
\end{figure}


Dado que la aplicación necesitará hacer uso de módulos nativos de los teléfonos, será necesario implementarlos para cada plataforma.
Esto se puede hacer de manera sencilla, ya que el framework permite la creación de módulos nativos los cuales se pueden llamar desde el código escrito con React.

Este es uno de los puntos fuertes de la aplicación, ya que permitirá programar haciendo uso de React, el cual es un framework muy conocido y utilizado, pero a la vez permite usar módulos nativos de cada plataforma, lo que da una gran flexibilidad a la hora de desarrollar la aplicación de forma nativa en todas las plataformas.

Lynx usa una aplicación nativa \textit{Lynx Explorer}, con la cual se puede visualizar el estado de la aplicación conforme se va desarrollando en tiempo real.
Esta aplicación se encarga de ejecutar el código compilado de Lynx.js y permite debuggear la aplicación gracias a su \href{https://github.com/lynx-family/lynx-devtool}{herramienta de depuración}.
Para poder hacer uso de los módulos nativos es necesario implementarlos en el Explorer, un proyecto que implementa el runtime que utiliza Lynx.js por debajo tanto en Android como iOS, compilar el código del mismo y una vez se ha compilado la aplicación con nuestro módulo nativo, se puede llamar a la implementación nativa desde la aplicación escrita en Lynx.js.

A la hora de compilar la aplicación para ser usada en producción, Lynx se incorpora sobre un SDK de Android o iOS. Gracias a esto se puede incorporar la aplicación en cualquier otra aplicación existente con tan solo compilar el código y añadirlo con el SDK de Lynx en la plataforma que se desee.
En este caso se usará una estructura de aplicación que proporcionan en \href{https://github.com/lynx-family/integrating-lynx-demo-projects}{su repositorio oficial de proyectos de ejemplo}, los cuales contienen proyectos vacíos que hacen uso de el SDK correspondiente en cada plataforma, por lo que tan solo será necesario incorporar la aplicación hecha con Lynx.js compilada y compilar el proyecto para cada plataforma.

El proceso de compilación de una aplicación para producción sigue siendo complejo aún, ya que tal y como se ha comentado, Lynx.js no tiene aún una manera definitiva de compilar un proyecto sin tener que integrarlo mediante el SDK de Lynx en un proyecto nativo de Android o iOS. Aún así, el repositorio con los proyectos de ejemplo proporciona una buena base para empezar a trabajar con Lynx.js y permite el desarrollo de la aplicación sin tener que preocuparnos por la configuración del proyecto.

Todo esto, junto con los comandos y repositorios necesarios viene detallado en el artículo hecho por el equipo de Lynx \parencite{lynx-native-modules}.

Dado que para el desarrollo de aplicaciones en iOS es necesario tener un sistema de Apple, este proyecto se centrará únicamente en la aplicación para Android, aunque el código de la aplicación será el mismo para ambas plataformas a diferencia de la implementación de los módulos nativos, que serán diferentes para cada plataforma.

En resumen, las ventajas de usar este framework con respecto a otros son:
\begin{itemize}
    \item \textbf{Rendimiento}: al compilar a código nativo, el rendimiento es mucho mejor que el de otros frameworks como Flutter. Además, Lynx ofrece una tecnología de doble hilo, haciendo que la aplicación sea mucho más fluida y rápida en comparación con otras tecnologías.
    \item \textbf{Flexibilidad}: permite la creación de módulos nativos para cada plataforma, lo que da una gran flexibilidad a la hora de desarrollar la aplicación.
    \item \textbf{Simplicidad}: la sintaxis es muy similar a la de React, lo que facilita su aprendizaje para los programadores que ya tienen experiencia en este framework.
    \item \textbf{Documentación}: la documentación es muy completa y está en constante actualización.
\end{itemize}

¿Por qué no se ha optado por otras opciones como Flutter o Kotlin Multiplatform?
\begin{itemize}
    \item \textbf{Flutter}: aunque es un framework muy potente y con una comunidad muy activa, su rendimiento no es tan bueno como el de Lynx.js.
        Flutter renderiza un ``canvas'' que utiliza un motor gráfico que se asemeja a un motor para juegos para renderizar la interfaz de usuario, haciendo que la experiencia de usuario no sea tan fluida como podría ser la de otro framework.
    \item \textbf{Kotlin Multiplatform}: aunque es una opción interesante, la comunidad y la documentación son mucho más limitadas que las de Lynx.js. La curva de aprendizaje es mucho más pronunciada, ya que se utiliza Kotlin junto con una gran cantidad de librerías las cuales necesitan de un estudio profundo para su uso.

        Aportaría el mejor rendimiento sin tener que programar la aplicación de forma nativa para todos los dispositivos (los dispositivos comparten código pero hay que implementar la mayoría de forma nativa para las distintas plataformas), pero el desarrollo sería mucho más lento y tedioso, lo cual además complicaría la aportación al proyecto Open Source.
    \item \textbf{React Native}: aunque es un framework muy conocido y utilizado, su rendimiento no es tan bueno como el de Lynx.js.
        Es una opción muy parecida a Lynx.js, pero a largo plazo la aplicación podría verse afectada por el rendimiento.
        Dada la similitud con Lynx.js y las ventajas que ofrece, se ha optado por este último.
\end{itemize}

Este framework ha sido desarrollado de cero por el equipo de TikTok. Es utilizado por ellos para el desarrollo de varias de sus aplicaciones, por lo que aunque ha cambiado a ser Open-Source hace poco con su versión 3.2.0. Es un framework que ya ha sido probado en producción en aplicaciones como \textbf{TikTok Studio}, \textbf{Disney100 en TikTok}, \textbf{The Met Gala en TikTok} tal y como comentan en el artículo en el que anunciaron que Lynx.js pasaba a ser Open-Source \parencite{lynx-article}.

\subsection{Inicialización del entorno de desarrollo}
En esta sección se va a detallar cómo se ha procedido a la inicialización del entorno de desarrollo tanto para el servidor como para la aplicación móvil.
\paragraph{Servidor}
\subparagraph{}
Para la inicialización del entorno de desarrollo del servidor se ha tomado como referencia la estructura de ejemplo que se puede encontrar en el artículo consultado sobre la arquitectura hexagonal en Rust \parencite{rust-hexagonal-architecture}. Éste quedaría de la siguiente manera:
\dirtree{%
.1 /.
.2 migrations/.
.3 20240603122606\_create\_authors.down.sql.
.3 20240603122606\_create\_authors.up.sql.
.2 src/.
.3 bin/.
.4 server/.
.5 main.rs.
.3 lib/.
.4 domain/.
.5 blog/.
.6 models/.
.7 author.rs.
.6 models.rs.
.6 ports.rs.
.6 service.rs.
.5 blog.rs.
.4 inbound/.
.5 http/.
.6 handlers/.
.7 create\_author.rs.
.6 handlers.rs.
.6 responses.rs.
.5 http.rs.
.4 outbound/.
.5 email\_client.rs.
.5 prometheus.rs.
.5 sqlite.rs.
.4 config.rs.
.4 domain.rs.
.4 inbound.rs.
.4 lib.rs.
.4 outbound.rs.
.2 .env.template.
.2 .gitignore.
.2 Cargo.lock.
.2 Cargo.toml.
.2 LICENSE.
.2 README.md.
}

Se define la siguiente estructura:
\begin{itemize}
    \item \textbf{migrations}: esta carpeta contiene los archivos de migración de la base de datos, que se utilizan para crear y actualizar la estructura de la base de datos. En este caso, contiene un archivo para crear la tabla de autores. Esta carpeta contiene todos los archivos necesarios para inicializar la base de datos y para borrarla si es necesario.
    \item \textbf{src}: esta carpeta contiene todo el código fuente del servidor, con las siguientes subcarpetas:
        \begin{itemize}
            \item \textbf{bin}: contiene el código que se ejecuta al iniciar el servidor, el punto de entrada de la aplicación. En esta carpeta no hay ningún tipo de lógica implementada, tan solo se inicializa el servidor, se definen las implementaciones de las interfaces y se inicia el servidor con las dependencias que necesite.
            \item \textbf{lib}: esta carpeta contiene todo el código de la aplicación, dividido siguiendo una filosofía hexagonal de la siguiente manera:
                \begin{itemize}
                    \item \textbf{domain}: contiene el código del dominio de la aplicación, es decir, la lógica de negocio. Se definen los modelos, puertos (interfaces) y servicios que se utilizan en la aplicación.
                    \item \textbf{inbound}: contiene el código de la capa de entrada de la aplicación, es decir, las interfaces que se exponen al exterior. En este caso, contiene un módulo HTTP que define los handlers (controladores) que se encargan de recibir las peticiones HTTP y devolver las respuestas correspondientes.
                    \item \textbf{outbound}: contiene el código de la capa de salida de la aplicación, es decir, las implementaciones de las interfaces que se utilizan en la capa de dominio. En este caso, contiene un cliente de correo electrónico, un cliente de Prometheus y un cliente SQLite que se encargan de enviar correos electrónicos, exponer métricas y acceder a la base de datos respectivamente.
                    \item \textbf{config.rs}: contiene la configuración de la aplicación, como las variables de entorno y los parámetros de configuración.
                    \item Los demás archivos definen los módulos de Rust.
                \end{itemize}
        \end{itemize}
\end{itemize}

Además de esos archivos, existen los archivos típicos de un proyecto de Rust, como son el \texttt{Cargo.toml} y el \texttt{Cargo.lock}, que definen las dependencias del proyecto y la versión de las mismas, así como el archivo \texttt{README.md} que contiene la documentación del proyecto y el archivo \texttt{LICENSE} que contiene la licencia del proyecto. Tanto el archivo \texttt{README.md} como el \texttt{LICENSE} se han redactado en inglés al igual que todo el código, puesto que el proyecto está pensado para ser Open-Source y se busca que cualquier persona pueda entenderlo y contribuir al mismo.

En este proyecto, tal y como se ha definido anteriormente, se utiliza un enfoque de arquitectura monolítica modular siguiendo el patrón de código \acrshort{cqrs}.
En este enfoque, los archivos van a estar organizados en módulos en vez de agrupados por capas, lo que permite definir de una manera más clara y flexible las funcionalidades de cada módulo.
Además, en la capa de aplicación se separan los casos de uso en comandos y consultas (las consultas son las que se encargan de obtener datos y los comandos son los que se encargan de modificar el estado del sistema), lo que permite tener una mejor organización del código y una mayor flexibilidad a la hora de añadir nuevas funcionalidades.

Este es un enfoque común en aplicaciones web modernas, ya que gracias a esto se puede conseguir funcionalidades como añadir caché a las consultas, realizar pruebas unitarias de los comandos y consultas de manera independiente, y tener una mejor organización del código en general.

Si se adaptara este proyecto de ejemplo a la estructura que se utilizará, la estructura sería de la siguiente manera:

\newpage
\dirtree{%
.1 /.
.2 migrations/.
.3 20240603122606\_create\_authors.down.sql.
.3 20240603122606\_create\_authors.up.sql.
.2 src/.
.3 bin/.
.4 server/.
.5 main.rs.
.3 lib/.
.4 blog/.
.5 domain/.
.6 models.rs.
.6 models/.
.7 author.rs.
.6 ports.rs.
.5 application/.
.6 commands/.
.7 create\_author.rs.
.6 queries/.
.7 get\_authors.rs.
.5 infrastructure/.
.6 sqlite.rs.
.6 email\_client.rs.
.5 interface/.
.6 http/.
.7 handlers.rs.
.7 handlers/.
.8 create\_author.rs.
.7 responses.rs.
.4 monitoring/.
.5 infrastructure/.
.6 prometheus.rs.
.4 shared/.
.5 config.rs.
.5 lib.rs.
.2 .env.template.
.2 .gitignore.
.2 Cargo.lock.
.2 Cargo.toml.
.2 LICENSE.
.2 README.md.
}

\paragraph{Cliente móvil}
\subparagraph{}
Siguiendo la arquitectura limpia para una aplicación móvil, definida en la Figura \ref{fig:clean-architecture-mobile}, la estructura del cliente móvil es muy similar a la del servidor, pero con algunas diferencias.

En este caso no se utiliza el patrón de código \acrshort{cqrs}, ya que no es necesario en una aplicación móvil, pero sí se sigue una estructura modular similar a la del servidor, donde cada módulo tiene una responsabilidad clara y bien definida.
La única adición que se presenta con respecto a la estructura del servidor es que en la aplicación móvil existe una capa de presentación que se encarga de la interfaz de usuario y de la interacción con el usuario, la cual sería la equivalente a la capa de interface que se definió en el servidor para la comunicación con el exterior (en el caso del servidor, mediante comunicación HTTP).

Una estructura de ejemplo para una aplicación móvil podría ser la siguiente:

\dirtree{%
.1 mobile-app/.
.2 src/.
.3 modules/.
.4 blog/.
.5 domain/.
.5 application/.
.6 services/.
.7 authorService.ts.
.7 blogService.ts.
.5 infrastructure/.
.5 presentation/.
.4 monitoring/.
.5 application/.
.6 services/.
.7 monitoringService.ts.
.5 infrastructure/.
.5 presentation/.
.4 shared/.
.5 config/.
.5 application/.
.6 services/.
.7 httpService.ts.
.7 storageService.ts.
.5 infrastructure/.
.5 presentation/.
.5 types/.
.3 navigation/.
.3 App.tsx.
.2 assets/.
.2 \_\_tests\_\_/.
.2 archivos de configuración del proyecto...
}

La principal diferencia que hay con respecto al servidor es que en la capa de aplicación no se seguirá un patrón CQRS y se implementarán servicios que se encargan de toda la lógica.
Además, la capa de interfaz se cambia por una capa de presentación, que se encargará de la interfaz de usuario y de la interacción con el usuario.

Para la inicialización del entorno de desarrollo del cliente móvil, además del directorio que implementa la aplicación usando Lynx.js se necesitará un directorio para el código de Lynx Explorer, puesto que se realizará una implementación de módulos nativos para acceder a funcionalidades como el acceso a imágenes en el dispositivo tanto como para gestionar los permisos necesarios de la aplicación.
Toda la documentación que se ha utilizado para inicializar el directorio de Lynx Explorer se puede encontrar en la \href{https://lynxjs.org/guide/use-native-modules.html#platform=android}{documentación oficial de Lynx.js} sobre implementación de módulos nativos.


\input{sections/sprints/sprint1}
\input{sections/sprints/sprint2}
\input{sections/sprints/sprint3}
