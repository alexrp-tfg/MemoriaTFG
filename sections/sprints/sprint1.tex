\section{Sprint 1}
Tal y como se ha definido en la sección \ref{sec:planificacion-inicial}, el primer sprint se centra en la base de nuestra aplicación web, desarrollando la estructura inicial del servidor, gestión de usuarios y subida y descarga sencilla de archivos.
Para ello, se han elegido las historias de usuario relacionadas con el objetivo de este sprint y se han desarrollado definiendo sub-historias de usuario si fueran necesarias, criterios de aceptación y las tareas necesarias para su implementación.

Las historias de usuario se han seleccionado de manera aproximada, puesto que al ser el primer sprint no tenemos una velocidad de equipo definida. Existe la posibilidad de que algunas historias de usuario no se completen en este sprint o de que se completen más de las previstas, por lo que se ha dejado un margen de maniobra para que el equipo pueda adaptarse a la realidad del desarrollo.

Cuando se termine el sprint, se calculará la velocidad del equipo la cual se utilizará para planificar los siguientes sprints, de manera que se pueda ajustar la cantidad de historias de usuario a desarrollar en cada uno de ellos.

Una vez definidas todas las tareas que se van a realizar en este sprint, se ha realizado un diagrama de Gantt para planificar el tiempo que se va a dedicar a cada una de ellas, teniendo en cuenta que el sprint tiene una duración de dos semanas, y se dará un orden de prioridad a las tareas que se consideren más importantes para llegar a el objetivo del sprint.

\subsection{Historias de usuario}
En esta sección se detallan las historias de usuario y técnicas que se han elegido para este sprint. Se va a hacer una breve descripción de cada una de ellas, así como los criterios de aceptación y las tareas necesarias para su implementación. Si fuera necesario, se definirán sub-historias de usuario para facilitar su desarrollo.

Las seleccionadas son las siguientes:
\begin{itemize}
    \item HU05: Inicio de sesión - 5 PH
    \item HU06: Cerrar sesión - 2 PH
    \item HU13: Crear cuentas - 8 PH
    \item HT03 API REST en Rust - 13 PH
    \item HT05: Autenticación JWT - 5 PH
    \item HT08: Base de datos - 8 PH
    \item HT18.1: Binario - 2 PH
    \item HT19: Dockerización - 3 PH
    \item HT20.1: Documentación del proyecto en GitHub - 5 PH
    \item HT20.2: Documentación de la API REST con OpenAPI - 5 PH
\end{itemize}

Estas historias de usuario y técnicas suman un total de 56 puntos de historia (PH). Es importante destacar que la estimación en puntos de historia representa la complejidad relativa de cada historia, mientras que las tareas de desarrollo se estiman en horas de trabajo efectivo.

\subsection{Descomposición en tareas de desarrollo}

% HU05: Inicio de sesión
\begin{table}[H]
    \begin{center}
        \begin{tabularx}{\textwidth}{|l|X|l|}
            \hline
            \textbf{Identificador HU05} & 
            \textbf{Como usuario, quiero iniciar sesión con contraseña o clave, para evitar que otros accedan a mis archivos} &
            \textbf{Estimación: 5 PH}\\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \begin{minipage}{\textwidth}
                    \centering
                    \vspace{0.5em}
                    \begin{tabular}{|l|p{8cm}|r|}
                        \hline
                        \textbf{Identificador} & \textbf{Título de la tarea de desarrollo} & \makecell{\textbf{Estimación}\\\textbf{(h)}} \\
                        \hline
                        Tarea 5-1U & Implementar endpoint para iniciar sesión & 2 \\
                        \hline
                        Tarea 5-2U & Validar credenciales de usuario contra la base de datos & 1.5 \\
                        \hline
                        Tarea 5-3U & Generar y devolver token JWT al usuario autenticado & 1.5 \\
                        \hline
                        Tarea 5-4U & Gestionar errores de autenticación (usuario no existe, contraseña incorrecta) & 1.5 \\
                        \hline
                        Tarea 5-5U & Documentar el endpoint de inicio de sesión en OpenAPI & 0.5 \\
                        \hline
                    \end{tabular}
                    \vspace{0.5em}
                \end{minipage}
            } \\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Pruebas de aceptación:}
                    \begin{itemize}
                        \item El usuario puede iniciar sesión con su contraseña.
                        \item Cuando el usuario inicia sesión, se le devuelve un token JWT.
                        \item Si el usuario no existe, se devuelve un mensaje de error.
                        \item Si la contraseña o clave son incorrectas, se devuelve un mensaje de error.
                        \item El endpoint está documentado en OpenAPI.
                    \end{itemize}
            }\\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Observaciones:}
                \begin{itemize}
                    \item El endpoint debe ser seguro (usar HTTPS).
                    \item El token JWT debe tener expiración configurable.
                \end{itemize}
            }\\
            \hline
        \end{tabularx}
    \end{center}
\end{table}

% HU06: Cerrar sesión
\begin{table}[H]
    \begin{center}
        \begin{tabularx}{\textwidth}{|l|X|l|}
            \hline
            \textbf{Identificador HU06} & 
            \textbf{Como usuario, quiero poder cerrar sesión en un dispositivo, para proteger mis datos si pierdo el móvil} &
            \textbf{Estimación: 2 PH}\\
            \hline
            \multicolumn{3}{|c|}{
                \begin{minipage}{\linewidth}
                    \centering
                    \vspace{0.5em}
                    \begin{tabular}{|l|p{8cm}|r|}
                        \hline
                        \textbf{Identificador} & \textbf{Título de la tarea de desarrollo} & \makecell{\textbf{Estimación}\\\textbf{(h)}} \\
                        \hline
                        Tarea 6-1 & Implementar endpoint para cerrar sesión (invalidar token JWT) & 1 \\
                        \hline
                        Tarea 6-2 & Gestionar lista negra de tokens JWT (opcional) & 1 \\
                        \hline
                    \end{tabular}
                    \vspace{0.5em}
                \end{minipage}
            } \\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Pruebas de aceptación:}
                    \begin{itemize}
                        \item El usuario puede cerrar sesión y su token queda invalidado.
                        \item Tras cerrar sesión, el token no permite acceder a endpoints protegidos.
                    \end{itemize}
            }\\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Observaciones:}
                \begin{itemize}
                    \item Si no se implementa lista negra, el token expira por tiempo.
                \end{itemize}
            }\\
            \hline
        \end{tabularx}
    \end{center}
\end{table}

% HU13: Crear cuentas
\begin{table}[H]
    \begin{center}
        \begin{tabularx}{\textwidth}{|l|X|l|}
            \hline
            \textbf{Identificador HU13} & 
            \textbf{Como administrador, quiero crear cuentas de usuario con permisos, para que varias personas puedan usar el servidor} &
            \textbf{Estimación: 8 PH}\\
            \hline
            \multicolumn{3}{|c|}{
                \begin{minipage}{\linewidth}
                    \centering
                    \vspace{0.5em}
                    \begin{tabular}{|l|p{8cm}|r|}
                        \hline
                        \textbf{Identificador} & \textbf{Título de la tarea de desarrollo} & \makecell{\textbf{Estimación}\\\textbf{(h)}} \\
                        \hline
                        Tarea 13-1 & Implementar endpoint para crear cuentas de usuario & 2 \\
                        \hline
                        Tarea 13-2 & Validar permisos de administrador para crear cuentas & 1.5 \\
                        \hline
                        Tarea 13-3 & Añadir roles/permisos a los usuarios & 1.5 \\
                        \hline
                        Tarea 13-4 & Gestionar almacenamiento seguro de contraseñas (hash) & 1.5 \\
                        \hline
                        Tarea 13-5 & Documentar el endpoint de creación de cuentas en OpenAPI & 0.5 \\
                        \hline
                        Tarea 13-6 & Pruebas unitarias de creación de usuario & 1 \\
                        \hline
                    \end{tabular}
                    \vspace{0.5em}
                \end{minipage}
            } \\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Pruebas de aceptación:}
                    \begin{itemize}
                        \item Solo el administrador puede crear cuentas.
                        \item El usuario creado puede iniciar sesión.
                        \item Los roles/permisos se asignan correctamente.
                        \item El endpoint está documentado en OpenAPI.
                    \end{itemize}
            }\\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Observaciones:}
                \begin{itemize}
                    \item Usar hash seguro para contraseñas (ej: Argon2).
                \end{itemize}
            }\\
            \hline
        \end{tabularx}
    \end{center}
\end{table}

% HT03: API REST en Rust
\begin{table}[H]
    \begin{center}
        \begin{tabularx}{\textwidth}{|l|X|l|}
            \hline
            \textbf{Identificador HT03} & 
            \textbf{Desarrollar API RESTful usando Rust y Axum} &
            \textbf{Estimación: 13 PH}\\
            \hline
            \multicolumn{3}{|c|}{
                \begin{minipage}{\linewidth}
                    \centering
                    \vspace{0.5em}
                    \begin{tabular}{|l|p{8cm}|r|}
                        \hline
                        \textbf{Identificador} & \textbf{Título de la tarea de desarrollo} & \makecell{\textbf{Estimación}\\\textbf{(h)}} \\
                        \hline
                        Tarea 3-1 & Crear estructura base del proyecto en Rust & 2 \\
                        \hline
                        Tarea 3-2 & Configurar Axum y dependencias principales & 2 \\
                        \hline
                        Tarea 3-3 & Definir rutas y controladores básicos & 2 \\
                        \hline
                        Tarea 3-4 & Implementar manejo de errores global & 2 \\
                        \hline
                        Tarea 3-5 & Añadir middlewares (logging, CORS, etc.) & 1.5 \\
                        \hline
                        Tarea 3-6 & Configurar variables de entorno y settings & 1.5 \\
                        \hline
                        Tarea 3-7 & Documentar endpoints iniciales & 1 \\
                        \hline
                        Tarea 3-8 & Pruebas de integración básicas & 1 \\
                        \hline
                    \end{tabular}
                    \vspace{0.5em}
                \end{minipage}
            } \\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Pruebas de aceptación:}
                    \begin{itemize}
                        \item El servidor arranca y responde a peticiones básicas.
                        \item Los endpoints definidos funcionan correctamente.
                        \item El manejo de errores es consistente.
                    \end{itemize}
            }\\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Observaciones:}
                \begin{itemize}
                    \item Seguir estructura modular y buenas prácticas de Rust.
                \end{itemize}
            }\\
            \hline
        \end{tabularx}
    \end{center}
\end{table}

% HT05: Autenticación JWT
\begin{table}[H]
    \begin{center}
        \begin{tabularx}{\textwidth}{|l|X|l|}
            \hline
            \textbf{Identificador HT05} & 
            \textbf{Implementar autenticación con JSON Web Tokens} &
            \textbf{Estimación: 5 PH}\\
            \hline
            \multicolumn{3}{|c|}{
                \begin{minipage}{\linewidth}
                    \centering
                    \vspace{0.5em}
                    \begin{tabular}{|l|p{8cm}|r|}
                        \hline
                        \textbf{Identificador} & \textbf{Título de la tarea de desarrollo} & \makecell{\textbf{Estimación}\\\textbf{(h)}} \\
                        \hline
                        Tarea 5-1T & Añadir librería de JWT y configuración & 1.5 \\
                        \hline
                        Tarea 5-2T & Implementar generación y validación de tokens & 1.5 \\
                        \hline
                        Tarea 5-3T & Proteger endpoints con autenticación JWT & 1 \\
                        \hline
                        Tarea 5-4T & Pruebas unitarias de autenticación & 1 \\
                        \hline
                    \end{tabular}
                    \vspace{0.5em}
                \end{minipage}
            } \\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Pruebas de aceptación:}
                    \begin{itemize}
                        \item Solo usuarios autenticados pueden acceder a endpoints protegidos.
                        \item Los tokens inválidos o expirados son rechazados.
                    \end{itemize}
            }\\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Observaciones:}
                \begin{itemize}
                    \item Usar claves seguras y expiración adecuada.
                \end{itemize}
            }\\
            \hline
        \end{tabularx}
    \end{center}
\end{table}

% HT08: Base de datos
\begin{table}[H]
    \begin{center}
        \begin{tabularx}{\textwidth}{|l|X|l|}
            \hline
            \textbf{Identificador HT08} & 
            \textbf{Implementar SQLite o PostgreSQL para usuarios y archivos} &
            \textbf{Estimación: 8 PH}\\
            \hline
            \multicolumn{3}{|c|}{
                \begin{minipage}{\linewidth}
                    \centering
                    \vspace{0.5em}
                    \begin{tabular}{|l|p{8cm}|r|}
                        \hline
                        \textbf{Identificador} & \textbf{Título de la tarea de desarrollo} & \makecell{\textbf{Estimación}\\\textbf{(h)}} \\
                        \hline
                        Tarea 8-1 & Definir modelo de datos para usuarios y archivos & 2 \\
                        \hline
                        Tarea 8-2 & Crear migraciones iniciales de la base de datos & 1.5 \\
                        \hline
                        Tarea 8-3 & Implementar acceso a base de datos en Rust & 2 \\
                        \hline
                        Tarea 8-4 & Pruebas de persistencia y consultas básicas & 1.5 \\
                        \hline
                    \end{tabular}
                    \vspace{0.5em}
                \end{minipage}
            } \\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Pruebas de aceptación:}
                    \begin{itemize}
                        \item Se pueden crear, consultar y modificar usuarios y archivos.
                        \item Las migraciones funcionan correctamente.
                    \end{itemize}
            }\\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Observaciones:}
                \begin{itemize}
                    \item Usar ORM recomendado para Rust (ej: sqlx, diesel).
                \end{itemize}
            }\\
            \hline
        \end{tabularx}
    \end{center}
\end{table}

% HT18.1: Binario
\begin{table}[H]
    \begin{center}
        \begin{tabularx}{\textwidth}{|l|X|l|}
            \hline
            \textbf{Identificador HT18.1} & 
            \textbf{Empaquetar la aplicación como un solo binario} &
            \textbf{Estimación: 2 PH}\\
            \hline
            \multicolumn{3}{|c|}{
                \begin{minipage}{\linewidth}
                    \centering
                    \vspace{0.5em}
                    \begin{tabular}{|l|p{8cm}|r|}
                        \hline
                        \textbf{Identificador} & \textbf{Título de la tarea de desarrollo} & \makecell{\textbf{Estimación}\\\textbf{(h)}} \\
                        \hline
                        Tarea 18.1-1 & Configurar build para generar binario único & 1.5 \\
                        \hline
                        Tarea 18.1-2 & Verificar funcionamiento del binario en distintos entornos & 0.5 \\
                        \hline
                    \end{tabular}
                    \vspace{0.5em}
                \end{minipage}
            } \\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Pruebas de aceptación:}
                    \begin{itemize}
                        \item El binario se genera correctamente y es ejecutable.
                        \item El binario funciona en los sistemas operativos objetivo.
                    \end{itemize}
            }\\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Observaciones:}
                \begin{itemize}
                    \item Documentar el proceso de build en el README.
                \end{itemize}
            }\\
            \hline
        \end{tabularx}
    \end{center}
\end{table}

% HT19: Dockerización
\begin{table}[H]
    \begin{center}
        \begin{tabularx}{\textwidth}{|l|X|l|}
            \hline
            \textbf{Identificador HT19} & 
            \textbf{Crear imagen Docker del servidor} &
            \textbf{Estimación: 3 PH}\\
            \hline
            \multicolumn{3}{|c|}{
                \begin{minipage}{\linewidth}
                    \centering
                    \vspace{0.5em}
                    \begin{tabular}{|l|p{8cm}|r|}
                        \hline
                        \textbf{Identificador} & \textbf{Título de la tarea de desarrollo} & \makecell{\textbf{Estimación}\\\textbf{(h)}} \\
                        \hline
                        Tarea 19-1 & Crear Dockerfile para el servidor & 1.5 \\
                        \hline
                        Tarea 19-2 & Configurar variables de entorno y volúmenes & 1 \\
                        \hline
                        Tarea 19-3 & Probar despliegue local y documentar uso & 0.5 \\
                        \hline
                    \end{tabular}
                    \vspace{0.5em}
                \end{minipage}
            } \\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Pruebas de aceptación:}
                    \begin{itemize}
                        \item El servidor se ejecuta correctamente en un contenedor Docker.
                        \item Se pueden configurar variables y volúmenes.
                    \end{itemize}
            }\\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Observaciones:}
                \begin{itemize}
                    \item Seguir buenas prácticas de Docker (multi-stage build si es posible).
                \end{itemize}
            }\\
            \hline
        \end{tabularx}
    \end{center}
\end{table}

% HT20.1: Documentación del proyecto en GitHub
\begin{table}[H]
    \begin{center}
        \begin{tabularx}{\textwidth}{|l|X|l|}
            \hline
            \textbf{Identificador HT20.1} & 
            \textbf{Documentar la instalación y uso del proyecto en el repositorio de Github} &
            \textbf{Estimación: 5 PH}\\
            \hline
            \multicolumn{3}{|c|}{
                \begin{minipage}{\linewidth}
                    \centering
                    \vspace{0.5em}
                    \begin{tabular}{|l|p{8cm}|r|}
                        \hline
                        \textbf{Identificador} & \textbf{Título de la tarea de desarrollo} & \makecell{\textbf{Estimación}\\\textbf{(h)}} \\
                        \hline
                        Tarea 20.1-1 & Redactar README con instrucciones de instalación & 1 \\
                        \hline
                        Tarea 20.1-2 & Documentar configuración y variables de entorno & 1 \\
                        \hline
                        Tarea 20.1-3 & Añadir ejemplos de uso y comandos básicos & 1 \\
                        \hline
                        Tarea 20.1-4 & Revisar y mejorar formato y claridad & 1 \\
                        \hline
                    \end{tabular}
                    \vspace{0.5em}
                \end{minipage}
            } \\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Pruebas de aceptación:}
                    \begin{itemize}
                        \item El README permite instalar y ejecutar el proyecto desde cero.
                        \item Toda la configuración necesaria está documentada.
                    \end{itemize}
            }\\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Observaciones:}
                \begin{itemize}
                    \item Usar ejemplos claros y comandos reproducibles.
                \end{itemize}
            }\\
            \hline
        \end{tabularx}
    \end{center}
\end{table}

% HT20.2: Documentación de la API REST con OpenAPI
\begin{table}[H]
    \begin{center}
        \begin{tabularx}{\textwidth}{|l|X|l|}
            \hline
            \textbf{Identificador HT20.2} & 
            \textbf{Documentar mediante la generación de una página web todos los endpoints de la API REST} &
            \textbf{Estimación: 5 PH}\\
            \hline
            \multicolumn{3}{|c|}{
                \begin{minipage}{\linewidth}
                    \centering
                    \vspace{0.5em}
                    \begin{tabular}{|l|p{8cm}|r|}
                        \hline
                        \textbf{Identificador} & \textbf{Título de la tarea de desarrollo} & \makecell{\textbf{Estimación}\\\textbf{(h)}} \\
                        \hline
                        Tarea 20.2-1 & Generar especificación OpenAPI de la API REST & 1.5 \\
                        \hline
                        Tarea 20.2-2 & Añadir descripciones y ejemplos a los endpoints & 1.5 \\
                        \hline
                        Tarea 20.2-3 & Publicar documentación como página web (Swagger UI u OpenAPI UI) & 1 \\
                        \hline
                        Tarea 20.2-4 & Revisar y mantener la documentación actualizada & 1 \\
                        \hline
                    \end{tabular}
                    \vspace{0.5em}
                \end{minipage}
            } \\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Pruebas de aceptación:}
                    \begin{itemize}
                        \item Todos los endpoints están documentados y accesibles vía web.
                        \item La documentación incluye ejemplos de peticiones y respuestas, tanto respuestas exitosas como errores.
                        \item La documentación se actualiza automáticamente al cambiar el código.
                    \end{itemize}
            }\\
            \hline
            \multicolumn{3}{|p{\textwidth}|}{
                \textbf{Observaciones:}
                \begin{itemize}
                    \item Usar herramientas automáticas para mantener la documentación sincronizada.
                \end{itemize}
            }\\
            \hline
        \end{tabularx}
    \end{center}
\end{table}

\paragraph{Resumen de estimación de tareas}

El total de horas estimadas para todas las tareas de desarrollo del Sprint 1 es de 56 horas, distribuidas de la siguiente manera:

\begin{itemize}
    \item HU05 (Inicio de sesión): 7 horas
    \item HU06 (Cerrar sesión): 2 horas  
    \item HU13 (Crear cuentas): 8 horas
    \item HT03 (API REST en Rust): 13 horas
    \item HT05 (Autenticación JWT): 5 horas
    \item HT08 (Base de datos): 7 horas
    \item HT18.1 (Binario): 2 horas
    \item HT19 (Dockerización): 3 horas
    \item HT20.1 (Documentación GitHub): 4 horas
    \item HT20.2 (Documentación OpenAPI): 5 horas
\end{itemize}

Esta estimación se ajusta perfectamente a la capacidad del sprint de 2 semanas con 4 horas diarias de dedicación (14 días × 4 horas = 56 horas totales).

Se puede ver que hay historias de usuario con los mismos puntos de historia o parecidos pero con diferente número de horas estimadas. Esto es normal, ya que los puntos de historia representan la complejidad relativa y no el tiempo exacto de desarrollo. Por ejemplo, una historia de usuario puede ser más compleja pero requerir menos tiempo si se reutilizan componentes existentes o se aprovechan bibliotecas ya implementadas.

\subsection{Diagrama de Gantt}
Dada las estimaciones de las tareas, se han considerado el siguiente orden de prioridad de tareas en un diagrama de Gantt:
\begin{figure}[H]
    \begin{center}
        \includegraphics[width=0.8\textwidth]{assets/sprint1/sprint1-week1.png}
    \end{center}
    \caption{Diagrama de Gantt de las tareas de la primera semana del sprint 1}\label{fig:sprint1-week1}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \includegraphics[width=0.8\textwidth]{assets/sprint1/sprint1-week2.png}
    \end{center}
    \caption{Diagrama de Gantt de las tareas de la segunda semana del sprint 1}\label{fig:sprint1-week2}
\end{figure}

Se ha seguido un orden lógico, en el que primero inicializaremos toda la capa de interfaz, en este caso nuestra API, junto con todas las dependencias que nos harán falta a la hora de documentar, errores no genéricos, variables de entorno, pruebas...

Después, se implementará el diseño de la base de datos. Una vez tenemos esta base, se implementarán las primeras funcionalidades, que van a ser la del inicio de sesión seguro, seguido de la gestión de cuentas. Para finalizar el sprint, se documentará todo al completo.

Para finalizar, configuraremos todo lo necesario para poder desplegar el servidor.

\subsection{Detalles de implementación}

\paragraph{Acceso a datos}
\subparagraph{}
Se ha optado por usar el \acrshort{orm} \textbf{Diesel} para el acceso a datos, ya que es uno de los más populares y robustos en el ecosistema de Rust. Diesel proporciona una interfaz segura y eficiente para interactuar con bases de datos SQL, lo que facilita la creación y gestión de esquemas, así como la ejecución de consultas.

Diesel nos proporciona un sistema de migraciones que nos permite versionar y gestionar los cambios en la estructura de la base de datos de manera controlada, generando esquemas que podemos utilizar a la hora de utilizar los métodos que nos proporciona el ORM. De esta manera, tendremos consultas seguras y tipadas.
Esto nos da una especial seguridad a la hora de hacer un desarrollo ágil, ya que podemos iterar rápidamente sobre el modelo de datos y asegurarnos de que los cambios se reflejan correctamente en la base de datos y en nuestro código, ya que hasta que no se solucionen los problemas de compilación provenientes de los cambios en la infraestructura, no se podrá seguir avanzando.

\paragraph{Implementación de Arquitectura Limpia}
\subparagraph{}

Tal y como se ha descrito en apartados anteriores, se ha seguido una arquitectura limpia siguiendo el paradigma de programación \acrshort{cqrs}.

Para ello, se ha aprovechado el sistema de \textit{tipos genéricos} que ofrece Rust.

Los tipos genéricos en Rust permiten escribir código que puede funcionar con múltiples tipos de datos sin necesidad de duplicar el código. Se definen utilizando parámetros de tipo, que son identificadores que se reemplazan por tipos concretos cuando se utiliza el código genérico.

En una arquitectura limpia, los tipos genéricos facilitan la creación de componentes reutilizables e independientes de la implementación concreta. Por ejemplo, se puede definir una interfaz (trait en Rust) para un repositorio de datos y luego implementar diferentes repositorios (e.g., uno para una base de datos y otro para un archivo) que implementen ese trait. Los tipos genéricos permiten que las capas superiores de la aplicación interactúen con el repositorio a través del trait, sin necesidad de conocer la implementación concreta. Esto facilita la inyección de dependencias, donde se puede pasar una implementación concreta del repositorio a la capa superior en tiempo de ejecución.

Los traits en Rust definen un conjunto de métodos que un tipo debe implementar para ser considerado como una instancia de ese trait, se podría considerar que son las ``interfaces'' de Rust. Los traits se pueden usar con tipos genéricos para restringir los tipos que se pueden usar con una función o estructura genérica. Por ejemplo, se puede definir una función genérica que solo funcione con tipos que implementen el trait `Display`.

De esta manera, definimos los traits que nos van a hacer falta en el dominio y cuando queremos usarlo en alguna función, simplemente le pasamos el tipo genérico que está definido en el dominio.
A la hora de inicializar nuestra aplicación es cuando vamos a instanciar los tipos concretos que implementan esos traits que vamos a usar, los cuales se van a inyectar en donde haga falta, por lo general en un estado global de la aplicación, el cual es accesible desde cualquier hilo de ejecución.

Esto se puede ver en el siguiente ejemplo, donde definimos un trait que representa un repositorio de usuarios y luego implementamos el repositorio que accederá a la base de datos mediante el ORM \textbf{Diesel}:

\begin{lstlisting}[language=Rust, caption={Trait de repositorio de usuarios}, label={lst:trait-repository}]
// src/lib/users/domain/user_repository.rs
use std::future::Future;

use crate::users::domain::{user::NewUser, User};

pub trait UserRepository: Clone + Send + Sync + 'static {
    fn get_by_username(
        &self,
        username: String,
    ) -> impl Future<Output = Result<Option<User>, UserRepositoryError>> + Send;
    fn create_user(&self, user: NewUser) -> impl Future<Output = Result<User, UserRepositoryError>> + Send;
}

#[derive(Debug, thiserror::Error)]
pub enum UserRepositoryError {
    #[error("User already exists")]
    UserAlreadyExists,
    #[error("Unexpected error")]
    InternalServerError,
}
\end{lstlisting}
Hemos definido un trait que será usado para acceder de alguna manera que nuestra capa de aplicación no va a saber. Además, se definen errores de dominio, los cuales no tienen nada que ver con cualquier error que pueda ocurrir al acceder a los datos en la base de datos o el sistema que se esté usando.

Además, el trait especifica que su implementación debe también implementar Clone, Send y Sync, asegurando que se pueda utilizar de manera segura entre hilos. Esto es importante para que nuestro repositorio pueda ser usado en un entorno asíncrono y concurrente.

\begin{lstlisting}[language=Rust, caption={Implementación del repositorio de usuarios}, label={lst:impl-repository}]
// src/lib/users/infrastructure/diesel_user_repository.rs
#[derive(Clone)]
pub struct DieselUserRepository {
    pool: Arc<Pool<ConnectionManager<PgConnection>>>,
}

impl DieselUserRepository {
    pub fn new(connection: Arc<Pool<ConnectionManager<PgConnection>>>) -> Self {
        DieselUserRepository { pool: connection }
    }
}

impl UserRepository for DieselUserRepository {
    async fn create_user(&self, new_user: NewUser) -> Result<User, UserRepositoryError> {
        // Implementación de la creación de usuario usando diesel
    }

    async fn get_by_username(
        &self,
        user_username: String,
    ) -> Result<Option<User>, UserRepositoryError> {
        // Implementación de la obtención de usuario por nombre de usuario usando diesel
    }
}
\end{lstlisting}

Aquí podemos ver una implementación del trait que hemos definido anteriormente, en este caso para acceder a una base de datos PostgreSQL mediante el ORM \textbf{Diesel}. Esta implementación es la que se inyectará en el estado global de nuestra aplicación cuando se inicialice.
En este caso, el repositorio implementa Send, Sync y Clone derivándolo de Clone, pues todas sus propiedades las implementan también haciendo que el repositorio lo implemente por ende.

El repositorio usará una pool de conexiones, pues al ser usado por varios hilos, necesitamos que cada hilo tenga su propia conexión a la base de datos para evitar bloqueos y problemas de concurrencia.

Una vez tenemos el trait y su implementación, tan solo nos va a quedar inyectar el repositorio en el estado global y utilizar el estado en nuestra capa de aplicación:
\begin{lstlisting}[language=Rust, caption={Inyección del repositorio en el estado global y uso en el comando para crear un usuario}, label={lst:inject-repository}]
// src/bin/server/main.rs
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    dotenvy::dotenv().ok();


    let connection_pool = Arc::new(establish_connection());

    let user_repository = DieselUserRepository::new(connection_pool);

    let server = HttpServer::new(user_repository).await?;

    server.run().await
}

// src/lib/users/interface/http/routes.rs
pub async fn create_user<UR: UserRepository>(
    State(state): State<AppState<UR>>,
    ValidatedJson(body): ValidatedJson<CreateUserCommand>,
) -> Result<(StatusCode, Json<ApiResponseBody<CreateUserResult>>), ApiError> {
    match create_user_command_handler(body, state.user_repository.as_ref()).await {
        Ok(user) => Ok((
            StatusCode::CREATED,
            ApiResponseBody::new(user).into(),
        )),
        Err(err) => match err {
            UserRepositoryError::UserAlreadyExists => Err(ApiError::ConflictError(err.to_string())),
            UserRepositoryError::InternalServerError => Err(ApiError::InternalServerError(err.to_string())),
        },
    }
}

// src/lib/users/application/commands/create_user.rs
pub async fn create_user_command_handler<UR: UserRepository>(
    mut command: CreateUserCommand,
    user_repository: &UR,
) -> Result<CreateUserResult, UserRepositoryError> {

    if user_repository.get_by_username(command.username.clone()).await?.is_some() {
        return Err(UserRepositoryError::UserAlreadyExists);
    }

    let salt = SaltString::generate(&mut OsRng);

    let argon2 = Argon2::default();

    command.password = argon2
        .hash_password(command.password.as_bytes(), &salt)
        .map_err(|_| UserRepositoryError::InternalServerError)?
        .to_string();

    Ok(user_repository.create_user(command.into()).await?.into())
}
\end{lstlisting}

Cuando definimos el estado global que va a extraer nuestro endpoint mediante el extractor que nos proporciona Axum, lo definimos con un tipo genérico \textit{UR}, el cual especificamos que va a implementar el trait \textit{UserRepository}. Es decir, sabemos los métodos que nos ofrece y las propiedades que tiene que tener, pero en la capa de aplicación no tenemos que conocer cómo se está implementando, solamente cómo se usa.

Otra buena práctica que podemos observar en el código es utilizar errores de dominio. De esta manera, abstraemos la capa de aplicación de cualquier tipo de error que pueda ocurrir en la capa de infraestructura y solamente en la capa de interfaz, que es la que presenta los datos al usuario, asociamos cada error de dominio al error correspondiente de interfaz.

Así, si quisiéramos cambiar cómo accedemos a los datos, tan solo tendríamos que crear o modificar la implementación que realizamos en la capa de infraestructura.

El siguiente diagrama muestra cómo se relacionan las diferentes capas de la arquitectura limpia que hemos implementado:
\begin{figure}[H]
    \begin{center}
        \includegraphics[width=0.95\textwidth]{assets/sprint1/diagrama-arquitectura-limpia.png}
    \end{center}
    \caption{Diagrama que muestra relaciones entre las capas para nuestra implementación.}\label{fig:diagrama-arquitectura-limpia-sprint1}
\end{figure}

\paragraph{Documentación de la API REST}
\subparagraph{}

Para documentar todos los endpoints de la API REST, se ha utilizado la especificación OpenAPI. Esta especificación permite describir de manera estructurada los endpoints, parámetros, tipos de datos y respuestas de la API.

Esta documentación se genera automáticamente mediante la librería \textbf{utoipa}, que se integra con Axum para generar la documentación a partir de los atributos y tipos definidos en el código. 
Esto asegura que la documentación esté siempre actualizada y refleje fielmente el estado actual de la API, por lo que cada vez que definamos un nuevo endpoint o modifiquemos uno existente, la documentación se actualizará automáticamente.

Además, se ha configurado otra librería compatible con utoipa \textbf{utoipa-swagger-ui}, que permite servir la documentación generada como una página web interactiva, lo que facilita a los desarrolladores y usuarios explorar y probar los endpoints de la API, mostrando ejemplos de peticiones, respuestas, errores y los esquemas usados en las peticiones y respuestas.
Además, nos permite probar los endpoints directamente desde la interfaz.

\paragraph{Pruebas unitarias y de integración}
\subparagraph{}

Para garantizar la calidad del código y el correcto funcionamiento de la aplicación, se han implementado pruebas unitarias y de integración utilizando la librería \textbf{tokio} para pruebas asíncronas y un \textbf{servicio oneshot} para simular el servidor HTTP.
El servicio oneshot no es más que un servidor HTTP con unas rutas definidas al igual que nuestra API, solo que es de un solo uso para realizar pruebas, ya que solamente deja simular una sola petición y respuesta, lo que es suficiente para nuestras pruebas unitarias.

En este punto es donde entra en juego una de las ventajas de utilizar una arquitectura limpia y CQRS.
Al separar la lógica de negocio de la infraestructura, podemos probar los comandos y consultas de manera aislada, sin necesidad de depender de la implementación concreta del repositorio o de la base de datos. Esto nos permite escribir pruebas más rápidas y enfocadas en la lógica de negocio.

Además, nos da la ventaja de poder \gls{mockear} los repositorios y otros componentes de infraestructura, lo que facilita la simulación de diferentes escenarios y errores en las pruebas.

Así, tendríamos la siguiente estructura en la carpeta de tests:

\dirtree{%
.1 tests.
.2 tests.rs.
.2 users.
.3 application.
.4 commands.
.5 test\_create\_user.rs.
.5 test\_login.rs.
.4 queries.
.5 test\_get\_all\_users.rs.
.5 test\_get\_user.rs.
.3 domain.
.4 auth.rs.
.4 roles.rs.
.4 user\_repository.rs.
.4 user.rs.
.3 infrastructure.
.4 test\_jwt\_token\_service.rs.
.4 test\_mappers.rs.
.4 test\_models.rs.
.4 test\_repository.rs.
.3 integration.
.4 test\_user\_endpoints.rs.
.3 mocks.rs.
.2 utils.
.3 functions.rs.
}

Como se puede ver, hemos separado las pruebas en diferentes carpetas según su tipo: pruebas de dominio, de infraestructura, de aplicación y de integración.
Se han abarcado todos los casos de uso definidos en las historias de usuario, asegurando que cada funcionalidad se prueba de manera aislada y también en conjunto con el resto del sistema.

Para ejecutar todos los tests, es tan sencillo como ejecutar el comando $cargo\ test$ en la raíz del proyecto, lo que ejecutará todas las pruebas definidas en la carpeta \texttt{tests} y mostrará los resultados en la consola.

\paragraph{Despliegue}
\subparagraph{}

Todos los pasos necesarios para el despliegue se han definido en el README del proyecto, donde se explica cómo construir el binario, cómo crear la imagen Docker y cómo ejecutar el servidor en un contenedor Docker, o directamente del binario compilado.

Nuestra aplicación depende de una base de datos PostgreSQL (de momento) y se ha generado un archivo docker compose para facilitar el despliegue de la aplicación junto con la base de datos. Este archivo define los servicios necesarios, incluyendo el servidor y la base de datos, y permite iniciar todo el entorno con un solo comando.

Si bien se puede utilizar docker compose para levantar el entorno de desarrollo, también se puede ejecutar el servidor directamente desde el binario generado, definiendo en las variables de entorno los parámetros necesarios para la base de datos, sin necesidad de usar Docker.
